This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: ui
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
ui/__init__.py
ui/chapters_tab.py
ui/character_tab.py
ui/config_tab.py
ui/context_menu.py
ui/directory_tab.py
ui/generation_handlers.py
ui/helpers.py
ui/main_tab.py
ui/main_window.py
ui/novel_params_tab.py
ui/other_settings.py
ui/role_library.py
ui/setting_tab.py
ui/summary_tab.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="ui/__init__.py">
# ui/__init__.py
from .main_window import NovelGeneratorGUI
</file>

<file path="ui/context_menu.py">
# ui/context_menu.py
# -*- coding: utf-8 -*-
import tkinter as tk
import customtkinter as ctk

class TextWidgetContextMenu:
    """
    ä¸º customtkinter.TextBox æˆ– tkinter.Text æä¾›å³é”®å¤åˆ¶/å‰ªåˆ‡/ç²˜è´´/å…¨é€‰çš„åŠŸèƒ½ã€‚
    """
    def __init__(self, widget):
        self.widget = widget
        self.menu = tk.Menu(widget, tearoff=0)
        self.menu.add_command(label="å¤åˆ¶", command=self.copy)
        self.menu.add_command(label="ç²˜è´´", command=self.paste)
        self.menu.add_command(label="å‰ªåˆ‡", command=self.cut)
        self.menu.add_separator()
        self.menu.add_command(label="å…¨é€‰", command=self.select_all)
        
        # ç»‘å®šå³é”®äº‹ä»¶
        self.widget.bind("<Button-3>", self.show_menu)
        
    def show_menu(self, event):
        if isinstance(self.widget, ctk.CTkTextbox):
            try:
                self.menu.tk_popup(event.x_root, event.y_root)
            finally:
                self.menu.grab_release()
            
    def copy(self):
        try:
            text = self.widget.get("sel.first", "sel.last")
            self.widget.clipboard_clear()
            self.widget.clipboard_append(text)
        except tk.TclError:
            pass  # æ²¡æœ‰é€‰ä¸­æ–‡æœ¬æ—¶å¿½ç•¥é”™è¯¯

    def paste(self):
        try:
            text = self.widget.clipboard_get()
            self.widget.insert("insert", text)
        except tk.TclError:
            pass  # å‰ªè´´æ¿ä¸ºç©ºæ—¶å¿½ç•¥é”™è¯¯

    def cut(self):
        try:
            text = self.widget.get("sel.first", "sel.last")
            self.widget.delete("sel.first", "sel.last")
            self.widget.clipboard_clear()
            self.widget.clipboard_append(text)
        except tk.TclError:
            pass  # æ²¡æœ‰é€‰ä¸­æ–‡æœ¬æ—¶å¿½ç•¥é”™è¯¯

    def select_all(self):
        self.widget.tag_add("sel", "1.0", "end")
</file>

<file path="ui/helpers.py">
# ui/helpers.py
# -*- coding: utf-8 -*-
import logging
import traceback

def log_error(message: str):
    logging.error(f"{message}\n{traceback.format_exc()}")
</file>

<file path="ui/other_settings.py">
# ui/other_settings.py
import customtkinter as ctk
from ui.config_tab import create_label_with_help
from tkinter import messagebox
from config_manager import load_config, save_config
import requests
from requests.auth import HTTPBasicAuth
import os
from xml.etree import ElementTree as ET
import shutil
import time
def build_other_settings_tab(self):
    self.other_settings_tab = self.tabview.add("Other Settings")
    self.other_settings_tab.rowconfigure(0, weight=1)
    self.other_settings_tab.columnconfigure(0, weight=1)
    if "webdav_config" not in self.loaded_config:
        self.loaded_config["webdav_config"] = {
            "webdav_url": "",
            "webdav_username": "",
            "webdav_password": ""
        }

    self.webdav_url_var.set(self.loaded_config["webdav_config"].get("webdav_url", ""))
    self.webdav_username_var.set(self.loaded_config["webdav_config"].get("webdav_username", ""))
    self.webdav_password_var.set(self.loaded_config["webdav_config"].get("webdav_password", ""))


    def save_webdav_settings():
        self.loaded_config["webdav_config"]["webdav_url"] = self.webdav_url_var.get().strip()
        self.loaded_config["webdav_config"]["webdav_username"] = self.webdav_username_var.get().strip()
        self.loaded_config["webdav_config"]["webdav_password"] = self.webdav_password_var.get().strip()
        save_config(self.loaded_config, self.config_file)


    def test_webdav_connection(test = True):
        try:
            client = WebDAVClient(self.webdav_url_var.get().strip(),self.webdav_username_var.get().strip(),self.webdav_password_var.get().strip())
            client.list_directory()
            if not test:
                save_webdav_settings()
                return True
            messagebox.showinfo("æˆåŠŸ", "WebDAV è¿æ¥æˆåŠŸï¼")
            save_webdav_settings()
            return True

        except Exception as e:
            print(e)

            messagebox.showerror("é”™è¯¯", f"å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return False

    def backup_to_webdav():
        try:
            target_dir = "AI_Novel_Generator"
            client = WebDAVClient(self.webdav_url_var.get().strip(),self.webdav_username_var.get().strip(),self.webdav_password_var.get().strip())
            if not client.ensure_directory_exists(target_dir):
                client.create_directory(target_dir)
            client.upload_file(self.config_file, f"{target_dir}/config.json")
            messagebox.showinfo("æˆåŠŸ", "é…ç½®å¤‡ä»½æˆåŠŸï¼")
        except Exception as e:
            print(e)
            messagebox.showerror("é”™è¯¯", f"å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return False







    def restore_from_webdav():
        try:
            target_dir = "AI_Novel_Generator"
            client = WebDAVClient(self.webdav_url_var.get().strip(),self.webdav_username_var.get().strip(),self.webdav_password_var.get().strip())
            client.download_file(f"{target_dir}/config.json", self.config_file)
            self.loaded_config = load_config(self.config_file)
            messagebox.showinfo("æˆåŠŸ", "é…ç½®æ¢å¤æˆåŠŸï¼")

        except Exception as e:
            print(e)
            messagebox.showerror("é”™è¯¯", f"å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
            return False




    dav_frame = ctk.CTkFrame(self.other_settings_tab)
    dav_frame.pack(padx=20, pady=20, fill="x")

    dav_title = ctk.CTkLabel(dav_frame, text="webdavè®¾ç½®", font=("Microsoft YaHei", 16, "bold"))
    dav_title.pack(anchor="w", padx=5, pady=(0, 5))
    dav_warp_frame = ctk.CTkFrame(dav_frame, corner_radius=10, border_width=2, border_color="gray")
    dav_warp_frame.pack(fill="x", padx=5)
    dav_warp_frame.columnconfigure(1, weight=1)

    

    create_label_with_help(self, parent=dav_warp_frame, label_text="Webdav URL", tooltip_key="webdav_url",row=0, column=0, font=("Microsoft YaHei", 12), sticky="w")
    dav_url_entry = ctk.CTkEntry(dav_warp_frame, textvariable=self.webdav_url_var, font=("Microsoft YaHei", 12))
    dav_url_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    create_label_with_help(self, parent=dav_warp_frame, label_text="Webdavç”¨æˆ·å", tooltip_key="webdav_username",row=1, column=0, font=("Microsoft YaHei", 12), sticky="w")
    dav_username_entry = ctk.CTkEntry(dav_warp_frame, textvariable=self.webdav_username_var, font=("Microsoft YaHei", 12))
    dav_username_entry.grid(row=1, column=1, padx=5, pady=5, sticky="w")

    create_label_with_help(self, parent=dav_warp_frame, label_text="Webdavå¯†ç ", tooltip_key="webdav_password",row=2, column=0, font=("Microsoft YaHei", 12), sticky="w")
    dav_password_entry = ctk.CTkEntry(dav_warp_frame, textvariable=self.webdav_password_var, font=("Microsoft YaHei", 12), show="*")
    dav_password_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")

    button_frame = ctk.CTkFrame(dav_warp_frame)
    button_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=10, sticky="w")
    
    # æµ‹è¯•è¿æ¥æŒ‰é’®
    test_btn = ctk.CTkButton(button_frame, text="æµ‹è¯•è¿æ¥", font=("Microsoft YaHei", 12),
                            command=test_webdav_connection)
    test_btn.pack(side="left", padx=5)
    
    # ä¿å­˜è®¾ç½®æŒ‰é’®
    save_btn = ctk.CTkButton(button_frame, text="å¤‡ä»½", font=("Microsoft YaHei", 12),
                            command=backup_to_webdav)
    save_btn.pack(side="left", padx=5)
    
    # é‡ç½®æŒ‰é’®
    reset_btn = ctk.CTkButton(button_frame, text="æ¢å¤", font=("Microsoft YaHei", 12),
                             command=restore_from_webdav)
    reset_btn.pack(side="left", padx=5)







class WebDAVClient:
    def __init__(self, base_url, username, password):
        """åˆå§‹åŒ–WebDAVå®¢æˆ·ç«¯"""
        self.base_url = base_url.rstrip('/') + '/'
        self.auth = HTTPBasicAuth(username, password)
        self.headers = {
            'User-Agent': 'Python WebDAV Client',
            'Accept': '*/*'
        }
        # WebDAVå‘½åç©ºé—´
        self.ns = {'d': 'DAV:'}

    def _get_url(self, path):
        """è·å–å®Œæ•´çš„èµ„æºURL"""
        return self.base_url + path.lstrip('/')

    def directory_exists(self, path):
        """
        æ£€æŸ¥ç›®å½•æ˜¯å¦å­˜åœ¨
        :param path: ç›®å½•è·¯å¾„
        :return: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºç›®å½•æ˜¯å¦å­˜åœ¨
        """
        url = self._get_url(path)
        headers = self.headers.copy()
        headers['Depth'] = '0'  # åªæ£€æŸ¥å½“å‰èµ„æº
        
        try:
            # å‘é€PROPFINDè¯·æ±‚æ£€æŸ¥èµ„æºæ˜¯å¦å­˜åœ¨
            response = requests.request('PROPFIND', url, headers=headers, auth=self.auth)
            
            # 207 Multi-Statusè¡¨ç¤ºæˆåŠŸï¼Œè¯´æ˜èµ„æºå­˜åœ¨
            if response.status_code == 207:
                # è§£æXMLå“åº”ï¼Œç¡®è®¤æ˜¯ç›®å½•
                root = ET.fromstring(response.content)
                # æŸ¥æ‰¾èµ„æºç±»å‹å±æ€§
                res_type = root.find('.//d:resourcetype', namespaces=self.ns)
                # å¦‚æœåŒ…å«collectionå…ƒç´ ï¼Œåˆ™æ˜¯ç›®å½•
                if res_type is not None and res_type.find('d:collection', namespaces=self.ns) is not None:
                    return True
            return False
        except requests.exceptions.RequestException as e:
            print(f"æ£€æŸ¥ç›®å½•å­˜åœ¨æ€§æ—¶å‡ºé”™: {e}")
            return False

    def create_directory(self, path):
        """
        åˆ›å»ºè¿œç¨‹ç›®å½•
        :param path: è¦åˆ›å»ºçš„ç›®å½•è·¯å¾„
        :return: æ˜¯å¦åˆ›å»ºæˆåŠŸ
        """
        url = self._get_url(path)
        
        try:
            response = requests.request('MKCOL', url, auth=self.auth, headers=self.headers)
            response.raise_for_status()
            
            print(f"ç›®å½•åˆ›å»ºæˆåŠŸ: {path}")
            return True
        except requests.exceptions.RequestException as e:
            print(f"ç›®å½•åˆ›å»ºå¤±è´¥: {e}")
            return False

    def ensure_directory_exists(self, path):
        """
        ç¡®ä¿ç›®å½•å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
        :param path: ç›®å½•è·¯å¾„
        :return: å¸ƒå°”å€¼ï¼Œè¡¨ç¤ºæœ€ç»ˆç›®å½•æ˜¯å¦å­˜åœ¨
        """
        # ç§»é™¤æœ«å°¾çš„æ–œæ ï¼ˆå¦‚æœæœ‰ï¼‰
        path = path.rstrip('/')
        
        # å¦‚æœç›®å½•å·²ç»å­˜åœ¨ï¼Œç›´æ¥è¿”å›True
        if self.directory_exists(path):
            print(f"ç›®å½•å·²å­˜åœ¨: {path}")
            return True
            
        # é€’å½’åˆ›å»ºçˆ¶ç›®å½•
        parent_dir = os.path.dirname(path)
        if parent_dir and not self.directory_exists(parent_dir):
            # å¦‚æœçˆ¶ç›®å½•ä¸å­˜åœ¨ï¼Œåˆ™å…ˆåˆ›å»ºçˆ¶ç›®å½•
            if not self.ensure_directory_exists(parent_dir):
                print(f"åˆ›å»ºçˆ¶ç›®å½•å¤±è´¥: {parent_dir}")
                return False
                
        # åˆ›å»ºå½“å‰ç›®å½•
        return self.create_directory(path)
    def upload_file(self, local_path, remote_path):
        """
        ä¸Šä¼ æ–‡ä»¶åˆ°WebDAVæœåŠ¡å™¨
        :param local_path: æœ¬åœ°æ–‡ä»¶è·¯å¾„
        :param remote_path: è¿œç¨‹æ–‡ä»¶è·¯å¾„
        :return: æ˜¯å¦ä¸Šä¼ æˆåŠŸ
        """
        if not os.path.isfile(local_path):
            print(f"æœ¬åœ°æ–‡ä»¶ä¸å­˜åœ¨: {local_path}")
            return False

        url = self._get_url(remote_path)
        
        try:
            with open(local_path, 'rb') as f:
                response = requests.put(url, data=f, auth=self.auth, headers=self.headers)
                response.raise_for_status()
            
            print(f"æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: {local_path} -> {remote_path}")
            return True
        except requests.exceptions.RequestException as e:
            print(f"æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {e}")
            return False
    def download_file(self, remote_path, local_path):
        """
        ä»WebDAVæœåŠ¡å™¨ä¸‹è½½æ–‡ä»¶
        :param remote_path: è¿œç¨‹æ–‡ä»¶è·¯å¾„
        :param local_path: æœ¬åœ°ä¿å­˜è·¯å¾„
        :return: æ˜¯å¦ä¸‹è½½æˆåŠŸ
        """
        url = self._get_url(remote_path)
        local_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), local_path)
        self.backup(local_path)
        try:
            response = requests.get(url, auth=self.auth, headers=self.headers, stream=True)
            response.raise_for_status()
            
            # åˆ›å»ºæœ¬åœ°ç›®å½•ï¼ˆå¦‚æœéœ€è¦ï¼‰
            os.makedirs(os.path.dirname(local_path), exist_ok=True)
            
            with open(local_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            print(f"æ–‡ä»¶ä¸‹è½½æˆåŠŸ: {remote_path} -> {local_path}")
            return True
        except requests.exceptions.RequestException as e:
            print(f"æ–‡ä»¶ä¸‹è½½å¤±è´¥: {e}")
            return False
    def backup(self, local_path):
        name_parts = os.path.basename(local_path).rsplit('.', 1)  # åªåˆ†å‰²æœ€åä¸€ä¸ªç‚¹
        base_name = name_parts[0]
        extension = name_parts[1]
        timestamp = time.strftime("%Y%m%d%H%M%S")
        if not os.path.exists(os.path.join(os.path.dirname(local_path), "backup")):
            os.makedirs(os.path.join(os.path.dirname(local_path), "backup"))
        backup_file_name = f"{base_name}_{timestamp}_bak.{extension}"
        shutil.copy2(os.path.basename(local_path), os.path.join(os.path.dirname(local_path), "backup", backup_file_name))
</file>

<file path="ui/chapters_tab.py">
# ui/chapters_tab.py
# -*- coding: utf-8 -*-
import os
import customtkinter as ctk
from tkinter import messagebox
from ui.context_menu import TextWidgetContextMenu
from utils import read_file, save_string_to_txt, clear_file_content

def build_chapters_tab(self):
    self.chapters_view_tab = self.tabview.add("Chapters Manage")
    self.chapters_view_tab.rowconfigure(0, weight=0)
    self.chapters_view_tab.rowconfigure(1, weight=1)
    self.chapters_view_tab.columnconfigure(0, weight=1)

    top_frame = ctk.CTkFrame(self.chapters_view_tab)
    top_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
    top_frame.columnconfigure(0, weight=0)
    top_frame.columnconfigure(1, weight=0)
    top_frame.columnconfigure(2, weight=0)
    top_frame.columnconfigure(3, weight=0)
    top_frame.columnconfigure(4, weight=1)

    prev_btn = ctk.CTkButton(top_frame, text="<< ä¸Šä¸€ç« ", command=self.prev_chapter, font=("Microsoft YaHei", 12))
    prev_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

    next_btn = ctk.CTkButton(top_frame, text="ä¸‹ä¸€ç«  >>", command=self.next_chapter, font=("Microsoft YaHei", 12))
    next_btn.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    self.chapter_select_var = ctk.StringVar(value="")
    self.chapter_select_menu = ctk.CTkOptionMenu(top_frame, values=[], variable=self.chapter_select_var, command=self.on_chapter_selected, font=("Microsoft YaHei", 12))
    self.chapter_select_menu.grid(row=0, column=2, padx=5, pady=5, sticky="w")

    save_btn = ctk.CTkButton(top_frame, text="ä¿å­˜ä¿®æ”¹", command=self.save_current_chapter, font=("Microsoft YaHei", 12))
    save_btn.grid(row=0, column=3, padx=5, pady=5, sticky="w")

    refresh_btn = ctk.CTkButton(top_frame, text="åˆ·æ–°ç« èŠ‚åˆ—è¡¨", command=self.refresh_chapters_list, font=("Microsoft YaHei", 12))
    refresh_btn.grid(row=0, column=5, padx=5, pady=5, sticky="e")

    self.chapters_word_count_label = ctk.CTkLabel(top_frame, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.chapters_word_count_label.grid(row=0, column=4, padx=(0,10), sticky="e")

    self.chapter_view_text = ctk.CTkTextbox(self.chapters_view_tab, wrap="word", font=("Microsoft YaHei", 12))
    
    def update_word_count(event=None):
        text = self.chapter_view_text.get("0.0", "end-1c")
        text_length = len(text)
        self.chapters_word_count_label.configure(text=f"å­—æ•°ï¼š{text_length}")
    
    self.chapter_view_text.bind("<KeyRelease>", update_word_count)
    self.chapter_view_text.bind("<ButtonRelease>", update_word_count)
    TextWidgetContextMenu(self.chapter_view_text)
    self.chapter_view_text.grid(row=1, column=0, sticky="nsew", padx=5, pady=5, columnspan=6)

    self.chapters_list = []
    refresh_chapters_list(self)

def refresh_chapters_list(self):
    filepath = self.filepath_var.get().strip()
    chapters_dir = os.path.join(filepath, "chapters")
    if not os.path.exists(chapters_dir):
        self.safe_log("å°šæœªæ‰¾åˆ° chapters æ–‡ä»¶å¤¹ï¼Œè¯·å…ˆç”Ÿæˆç« èŠ‚æˆ–æ£€æŸ¥ä¿å­˜è·¯å¾„ã€‚")
        self.chapter_select_menu.configure(values=[])
        return

    all_files = os.listdir(chapters_dir)
    chapter_nums = []
    for f in all_files:
        if f.startswith("chapter_") and f.endswith(".txt"):
            number_part = f.replace("chapter_", "").replace(".txt", "")
            if number_part.isdigit():
                chapter_nums.append(number_part)
    chapter_nums.sort(key=lambda x: int(x))
    self.chapters_list = chapter_nums
    self.chapter_select_menu.configure(values=self.chapters_list)
    current_selected = self.chapter_select_var.get()
    if current_selected not in self.chapters_list:
        if self.chapters_list:
            self.chapter_select_var.set(self.chapters_list[0])
            load_chapter_content(self, self.chapters_list[0])
        else:
            self.chapter_select_var.set("")
            self.chapter_view_text.delete("0.0", "end")

def on_chapter_selected(self, value):
    load_chapter_content(self, value)

def load_chapter_content(self, chapter_number_str):
    if not chapter_number_str:
        return
    filepath = self.filepath_var.get().strip()
    chapter_file = os.path.join(filepath, "chapters", f"chapter_{chapter_number_str}.txt")
    if not os.path.exists(chapter_file):
        self.safe_log(f"ç« èŠ‚æ–‡ä»¶ {chapter_file} ä¸å­˜åœ¨ï¼")
        return
    content = read_file(chapter_file)
    self.chapter_view_text.delete("0.0", "end")
    self.chapter_view_text.insert("0.0", content)

def save_current_chapter(self):
    chapter_number_str = self.chapter_select_var.get()
    if not chapter_number_str:
        messagebox.showwarning("è­¦å‘Š", "å°šæœªé€‰æ‹©ç« èŠ‚ï¼Œæ— æ³•ä¿å­˜ã€‚")
        return
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    chapter_file = os.path.join(filepath, "chapters", f"chapter_{chapter_number_str}.txt")
    content = self.chapter_view_text.get("0.0", "end").strip()
    clear_file_content(chapter_file)
    save_string_to_txt(content, chapter_file)
    self.safe_log(f"å·²ä¿å­˜å¯¹ç¬¬ {chapter_number_str} ç« çš„ä¿®æ”¹ã€‚")

def prev_chapter(self):
    if not self.chapters_list:
        return
    current = self.chapter_select_var.get()
    if current not in self.chapters_list:
        return
    idx = self.chapters_list.index(current)
    if idx > 0:
        new_idx = idx - 1
        self.chapter_select_var.set(self.chapters_list[new_idx])
        load_chapter_content(self, self.chapters_list[new_idx])
    else:
        messagebox.showinfo("æç¤º", "å·²ç»æ˜¯ç¬¬ä¸€ç« äº†ã€‚")

def next_chapter(self):
    if not self.chapters_list:
        return
    current = self.chapter_select_var.get()
    if current not in self.chapters_list:
        return
    idx = self.chapters_list.index(current)
    if idx < len(self.chapters_list) - 1:
        new_idx = idx + 1
        self.chapter_select_var.set(self.chapters_list[new_idx])
        load_chapter_content(self, self.chapters_list[new_idx])
    else:
        messagebox.showinfo("æç¤º", "å·²ç»æ˜¯æœ€åä¸€ç« äº†ã€‚")
</file>

<file path="ui/character_tab.py">
# ui/character_tab.py
# -*- coding: utf-8 -*-
import os
import customtkinter as ctk
from tkinter import messagebox
from utils import read_file, save_string_to_txt, clear_file_content
from ui.context_menu import TextWidgetContextMenu

def build_character_tab(self):
    self.character_tab = self.tabview.add("Character State")
    self.character_tab.rowconfigure(0, weight=0)
    self.character_tab.rowconfigure(1, weight=1)
    self.character_tab.columnconfigure(0, weight=1)

    load_btn = ctk.CTkButton(self.character_tab, text="åŠ è½½ character_state.txt", command=self.load_character_state, font=("Microsoft YaHei", 12))
    load_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

    self.character_wordcount_label = ctk.CTkLabel(self.character_tab, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.character_wordcount_label.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    save_btn = ctk.CTkButton(self.character_tab, text="ä¿å­˜ä¿®æ”¹", command=self.save_character_state, font=("Microsoft YaHei", 12))
    save_btn.grid(row=0, column=2, padx=5, pady=5, sticky="e")

    self.character_text = ctk.CTkTextbox(self.character_tab, wrap="word", font=("Microsoft YaHei", 12))
    
    def update_word_count(event=None):
        text = self.character_text.get("0.0", "end-1c")
        text_length = len(text)
        self.character_wordcount_label.configure(text=f"å­—æ•°ï¼š{text_length}")
    
    self.character_text.bind("<KeyRelease>", update_word_count)
    self.character_text.bind("<ButtonRelease>", update_word_count)
    TextWidgetContextMenu(self.character_text)
    self.character_text.grid(row=1, column=0, sticky="nsew", padx=5, pady=5, columnspan=3)

def load_character_state(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    filename = os.path.join(filepath, "character_state.txt")
    content = read_file(filename)
    self.character_text.delete("0.0", "end")
    self.character_text.insert("0.0", content)
    self.log("å·²åŠ è½½ character_state.txt åˆ°ç¼–è¾‘åŒºã€‚")

def save_character_state(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    content = self.character_text.get("0.0", "end").strip()
    filename = os.path.join(filepath, "character_state.txt")
    clear_file_content(filename)
    save_string_to_txt(content, filename)
    self.log("å·²ä¿å­˜å¯¹ character_state.txt çš„ä¿®æ”¹ã€‚")
</file>

<file path="ui/setting_tab.py">
# ui/setting_tab.py
# -*- coding: utf-8 -*-
import os
import customtkinter as ctk
from tkinter import messagebox
from utils import read_file, save_string_to_txt, clear_file_content
from ui.context_menu import TextWidgetContextMenu

def build_setting_tab(self):
    self.setting_tab = self.tabview.add("Novel Architecture")
    self.setting_tab.rowconfigure(0, weight=0)
    self.setting_tab.rowconfigure(1, weight=1)
    self.setting_tab.columnconfigure(0, weight=1)

    load_btn = ctk.CTkButton(self.setting_tab, text="åŠ è½½ Novel_architecture.txt", command=self.load_novel_architecture, font=("Microsoft YaHei", 12))
    load_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

    self.setting_word_count_label = ctk.CTkLabel(self.setting_tab, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.setting_word_count_label.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    save_btn = ctk.CTkButton(self.setting_tab, text="ä¿å­˜ä¿®æ”¹", command=self.save_novel_architecture, font=("Microsoft YaHei", 12))
    save_btn.grid(row=0, column=2, padx=5, pady=5, sticky="e")

    self.setting_text = ctk.CTkTextbox(self.setting_tab, wrap="word", font=("Microsoft YaHei", 12))
    TextWidgetContextMenu(self.setting_text)
    self.setting_text.grid(row=1, column=0, sticky="nsew", padx=5, pady=5, columnspan=3)

    def update_word_count(event=None):
        text = self.setting_text.get("0.0", "end")
        count = len(text) - 1
        self.setting_word_count_label.configure(text=f"å­—æ•°ï¼š{count}")

    self.setting_text.bind("<KeyRelease>", update_word_count)
    self.setting_text.bind("<ButtonRelease>", update_word_count)

def load_novel_architecture(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    filename = os.path.join(filepath, "Novel_architecture.txt")
    content = read_file(filename)
    self.setting_text.delete("0.0", "end")
    self.setting_text.insert("0.0", content)
    self.log("å·²åŠ è½½ Novel_architecture.txt å†…å®¹åˆ°ç¼–è¾‘åŒºã€‚")

def save_novel_architecture(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return
    content = self.setting_text.get("0.0", "end").strip()
    filename = os.path.join(filepath, "Novel_architecture.txt")
    clear_file_content(filename)
    save_string_to_txt(content, filename)
    self.log("å·²ä¿å­˜å¯¹ Novel_architecture.txt çš„ä¿®æ”¹ã€‚")
</file>

<file path="ui/summary_tab.py">
# ui/summary_tab.py
# -*- coding: utf-8 -*-
import os
import customtkinter as ctk
from tkinter import messagebox
from utils import read_file, save_string_to_txt, clear_file_content
from ui.context_menu import TextWidgetContextMenu

def build_summary_tab(self):
    self.summary_tab = self.tabview.add("Global Summary")
    self.summary_tab.rowconfigure(0, weight=0)
    self.summary_tab.rowconfigure(1, weight=1)
    self.summary_tab.columnconfigure(0, weight=1)
    self.summary_tab.columnconfigure(1, weight=0)
    self.summary_tab.columnconfigure(2, weight=0)

    load_btn = ctk.CTkButton(self.summary_tab, text="åŠ è½½ global_summary.txt", command=self.load_global_summary, font=("Microsoft YaHei", 12))
    load_btn.grid(row=0, column=0, padx=5, pady=5, sticky="w")

    self.word_count_label = ctk.CTkLabel(self.summary_tab, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.word_count_label.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    save_btn = ctk.CTkButton(self.summary_tab, text="ä¿å­˜ä¿®æ”¹", command=self.save_global_summary, font=("Microsoft YaHei", 12))
    save_btn.grid(row=0, column=2, padx=5, pady=5, sticky="e")

    self.summary_text = ctk.CTkTextbox(self.summary_tab, wrap="word", font=("Microsoft YaHei", 12))
    TextWidgetContextMenu(self.summary_text)
    self.summary_text.grid(row=1, column=0, sticky="nsew", padx=5, pady=5, columnspan=3)

    def update_word_count(event=None):
        text = self.summary_text.get("0.0", "end")
        count = len(text) - 1
        self.word_count_label.configure(text=f"å­—æ•°ï¼š{count}")

    self.summary_text.bind("<KeyRelease>", update_word_count)
    self.summary_text.bind("<ButtonRelease>", update_word_count)
def load_global_summary(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    filename = os.path.join(filepath, "global_summary.txt")
    content = read_file(filename)
    self.summary_text.delete("0.0", "end")
    self.summary_text.insert("0.0", content)
    self.log("å·²åŠ è½½ global_summary.txt åˆ°ç¼–è¾‘åŒºã€‚")

def save_global_summary(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    content = self.summary_text.get("0.0", "end").strip()
    filename = os.path.join(filepath, "global_summary.txt")
    clear_file_content(filename)
    save_string_to_txt(content, filename)
    self.log("å·²ä¿å­˜å¯¹ global_summary.txt çš„ä¿®æ”¹ã€‚")
</file>

<file path="ui/directory_tab.py">
# ui/directory_tab.py
# -*- coding: utf-8 -*-
import os
import customtkinter as ctk
from tkinter import messagebox
from utils import read_file, save_string_to_txt, clear_file_content
from ui.context_menu import TextWidgetContextMenu

def build_directory_tab(self):
    self.directory_tab = self.tabview.add("Chapter Blueprint")
    self.directory_tab.rowconfigure(0, weight=0)
    self.directory_tab.rowconfigure(1, weight=1)
    self.directory_tab.columnconfigure(0, weight=1)

    # åˆ›å»ºé¡¶éƒ¨æŒ‰é’®å®¹å™¨æ¡†æ¶ï¼Œæ–¹ä¾¿ç®¡ç†
    top_frame = ctk.CTkFrame(self.directory_tab, fg_color="transparent")
    top_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
    
    # åŠ è½½æŒ‰é’®
    load_btn = ctk.CTkButton(top_frame, text="åŠ è½½ Novel_directory.txt", command=self.load_chapter_blueprint, font=("Microsoft YaHei", 12))
    load_btn.pack(side="left", padx=5)

    # å­—æ•°ç»Ÿè®¡
    self.directory_word_count_label = ctk.CTkLabel(top_frame, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.directory_word_count_label.pack(side="left", padx=10)

    # ä¿å­˜æŒ‰é’®
    save_btn = ctk.CTkButton(top_frame, text="ä¿å­˜ä¿®æ”¹", command=self.save_chapter_blueprint, font=("Microsoft YaHei", 12))
    save_btn.pack(side="right", padx=5)

    # === æ–°å¢ï¼šå¾®è°ƒç›®å½•æŒ‰é’® ===
    refine_btn = ctk.CTkButton(top_frame, text="âœ¨ å¾®è°ƒç›®å½• (AI)", command=self.refine_directory_card_ui, font=("Microsoft YaHei", 12), fg_color="#E67E22")
    refine_btn.pack(side="right", padx=5)
    # ========================

    self.directory_text = ctk.CTkTextbox(self.directory_tab, wrap="word", font=("Microsoft YaHei", 12))
    
    def update_word_count(event=None):
        text = self.directory_text.get("0.0", "end")
        count = len(text) - 1
        self.directory_word_count_label.configure(text=f"å­—æ•°ï¼š{count}")
    
    self.directory_text.bind("<KeyRelease>", update_word_count)
    self.directory_text.bind("<ButtonRelease>", update_word_count)
    TextWidgetContextMenu(self.directory_text)
    self.directory_text.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)

def load_chapter_blueprint(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    filename = os.path.join(filepath, "Novel_directory.txt")
    content = read_file(filename)
    self.directory_text.delete("0.0", "end")
    self.directory_text.insert("0.0", content)
    self.log("å·²åŠ è½½ Novel_directory.txt å†…å®¹åˆ°ç¼–è¾‘åŒºã€‚")

def save_chapter_blueprint(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
    content = self.directory_text.get("0.0", "end").strip()
    filename = os.path.join(filepath, "Novel_directory.txt")
    clear_file_content(filename)
    save_string_to_txt(content, filename)
    self.log("å·²ä¿å­˜å¯¹ Novel_directory.txt çš„ä¿®æ”¹ã€‚")
</file>

<file path="ui/main_tab.py">
# ui/main_tab.py
# -*- coding: utf-8 -*-
import customtkinter as ctk
from tkinter import messagebox
from ui.context_menu import TextWidgetContextMenu

def build_main_tab(self):
    """
    ä¸»TabåŒ…å«å·¦ä¾§çš„"æœ¬ç« å†…å®¹"ç¼–è¾‘æ¡†å’Œè¾“å‡ºæ—¥å¿—ï¼Œä»¥åŠå³ä¾§çš„ä¸»è¦æ“ä½œå’Œå‚æ•°è®¾ç½®åŒº
    """
    self.main_tab = self.tabview.add("Main Functions")
    self.main_tab.rowconfigure(0, weight=1)
    self.main_tab.columnconfigure(0, weight=1)
    self.main_tab.columnconfigure(1, weight=0)

    self.left_frame = ctk.CTkFrame(self.main_tab)
    self.left_frame.grid(row=0, column=0, sticky="nsew", padx=2, pady=2)

    self.right_frame = ctk.CTkFrame(self.main_tab)
    self.right_frame.grid(row=0, column=1, sticky="nsew", padx=2, pady=2)

    build_left_layout(self)
    build_right_layout(self)

def build_left_layout(self):
    """
    å·¦ä¾§åŒºåŸŸï¼šæœ¬ç« å†…å®¹(å¯ç¼–è¾‘) + Stepæµç¨‹æŒ‰é’® + è¾“å‡ºæ—¥å¿—(åªè¯»)
    """
    self.left_frame.grid_rowconfigure(0, weight=0)
    self.left_frame.grid_rowconfigure(1, weight=2)
    self.left_frame.grid_rowconfigure(2, weight=0)
    self.left_frame.grid_rowconfigure(3, weight=0)
    self.left_frame.grid_rowconfigure(4, weight=1)
    self.left_frame.columnconfigure(0, weight=1)

    self.chapter_label = ctk.CTkLabel(self.left_frame, text="æœ¬ç« å†…å®¹ï¼ˆå¯ç¼–è¾‘ï¼‰  å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
    self.chapter_label.grid(row=0, column=0, padx=5, pady=(5, 0), sticky="w")

    # ç« èŠ‚æ–‡æœ¬ç¼–è¾‘æ¡†
    self.chapter_result = ctk.CTkTextbox(self.left_frame, wrap="word", font=("Microsoft YaHei", 14))
    TextWidgetContextMenu(self.chapter_result)
    self.chapter_result.grid(row=1, column=0, sticky="nsew", padx=5, pady=(0, 5))



    def update_word_count(event=None):
        text = self.chapter_result.get("0.0", "end")
        count = len(text) - 1  # å‡å»æœ€åä¸€ä¸ªæ¢è¡Œç¬¦
        self.chapter_label.configure(text=f"æœ¬ç« å†…å®¹ï¼ˆå¯ç¼–è¾‘ï¼‰  å­—æ•°ï¼š{count}")

    self.chapter_result.bind("<KeyRelease>", update_word_count)
    self.chapter_result.bind("<ButtonRelease>", update_word_count)

    # Step æŒ‰é’®åŒºåŸŸ
    self.step_buttons_frame = ctk.CTkFrame(self.left_frame)
    self.step_buttons_frame.grid(row=2, column=0, sticky="ew", padx=5, pady=5)
    self.step_buttons_frame.columnconfigure((0, 1, 2, 3, 4), weight=1)


    self.btn_generate_architecture = ctk.CTkButton(
        self.step_buttons_frame,
        text="Step1. ç”Ÿæˆæ¶æ„",
        command=self.generate_novel_architecture_ui,
        font=("Microsoft YaHei", 12)
    )
    self.btn_generate_architecture.grid(row=0, column=0, padx=5, pady=2, sticky="ew")

    self.btn_generate_directory = ctk.CTkButton(
        self.step_buttons_frame,
        text="Step2. ç”Ÿæˆç›®å½•",
        command=self.generate_chapter_blueprint_ui,
        font=("Microsoft YaHei", 12)
    )
    self.btn_generate_directory.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

    self.btn_generate_chapter = ctk.CTkButton(
        self.step_buttons_frame,
        text="Step3. ç”Ÿæˆè‰ç¨¿",
        command=self.generate_chapter_draft_ui,
        font=("Microsoft YaHei", 12)
    )
    self.btn_generate_chapter.grid(row=0, column=2, padx=5, pady=2, sticky="ew")

    self.btn_finalize_chapter = ctk.CTkButton(
        self.step_buttons_frame,
        text="Step4. å®šç¨¿ç« èŠ‚",
        command=self.finalize_chapter_ui,
        font=("Microsoft YaHei", 12)
    )
    self.btn_finalize_chapter.grid(row=0, column=3, padx=5, pady=2, sticky="ew")

    self.btn_batch_generate = ctk.CTkButton(
        self.step_buttons_frame,
        text="æ‰¹é‡ç”Ÿæˆ",
        command=self.generate_batch_ui,
        font=("Microsoft YaHei", 12)
    )
    self.btn_batch_generate.grid(row=0, column=4, padx=5, pady=2, sticky="ew")


    # æ—¥å¿—æ–‡æœ¬æ¡†
    log_label = ctk.CTkLabel(self.left_frame, text="è¾“å‡ºæ—¥å¿— (åªè¯»)", font=("Microsoft YaHei", 12))
    log_label.grid(row=3, column=0, padx=5, pady=(5, 0), sticky="w")

    self.log_text = ctk.CTkTextbox(self.left_frame, wrap="word", font=("Microsoft YaHei", 12))
    TextWidgetContextMenu(self.log_text)
    self.log_text.grid(row=4, column=0, sticky="nsew", padx=5, pady=(0, 5))
    self.log_text.configure(state="disabled")

def build_right_layout(self):
    """
    å³ä¾§åŒºåŸŸï¼šé…ç½®åŒº(tabview) + å°è¯´ä¸»å‚æ•° + å¯é€‰åŠŸèƒ½æŒ‰é’®
    """
    self.right_frame.grid_rowconfigure(0, weight=0)
    self.right_frame.grid_rowconfigure(1, weight=1)
    self.right_frame.grid_rowconfigure(2, weight=0)
    self.right_frame.columnconfigure(0, weight=1)

    # é…ç½®åŒºï¼ˆAI/Embeddingï¼‰
    self.config_frame = ctk.CTkFrame(self.right_frame, corner_radius=10, border_width=2, border_color="gray")
    self.config_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
    self.config_frame.columnconfigure(0, weight=1)
    # å…¶ä½™éƒ¨åˆ†å°†åœ¨ config_tab.py ä¸ novel_params_tab.py ä¸­æ„å»º
</file>

<file path="ui/novel_params_tab.py">
# ui/novel_params_tab.py
# -*- coding: utf-8 -*-
import customtkinter as ctk
from tkinter import filedialog, messagebox
from ui.context_menu import TextWidgetContextMenu
from tooltips import tooltips

def build_novel_params_area(self, start_row=1):
    self.params_frame = ctk.CTkScrollableFrame(self.right_frame, orientation="vertical")
    self.params_frame.grid(row=start_row, column=0, sticky="nsew", padx=5, pady=5)
    self.params_frame.columnconfigure(1, weight=1)

    # 1) ä¸»é¢˜(Topic)
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ä¸»é¢˜(Topic):", tooltip_key="topic", row=0, column=0, font=("Microsoft YaHei", 12), sticky="ne")
    self.topic_text = ctk.CTkTextbox(self.params_frame, height=80, wrap="word", font=("Microsoft YaHei", 12))
    TextWidgetContextMenu(self.topic_text)
    self.topic_text.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
    if hasattr(self, 'topic_default') and self.topic_default:
        self.topic_text.insert("0.0", self.topic_default)

    # 2) ç±»å‹(Genre)
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ç±»å‹(Genre):", tooltip_key="genre", row=1, column=0, font=("Microsoft YaHei", 12))
    genre_entry = ctk.CTkEntry(self.params_frame, textvariable=self.genre_var, font=("Microsoft YaHei", 12))
    genre_entry.grid(row=1, column=1, padx=5, pady=5, sticky="ew")

    # 3) ç« èŠ‚æ•° & æ¯ç« å­—æ•°
    row_for_chapter_and_word = 2
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ç« èŠ‚æ•° & æ¯ç« å­—æ•°:", tooltip_key="num_chapters", row=row_for_chapter_and_word, column=0, font=("Microsoft YaHei", 12))
    chapter_word_frame = ctk.CTkFrame(self.params_frame)
    chapter_word_frame.grid(row=row_for_chapter_and_word, column=1, padx=5, pady=5, sticky="ew")
    chapter_word_frame.columnconfigure((0, 1, 2, 3), weight=0)
    num_chapters_label = ctk.CTkLabel(chapter_word_frame, text="ç« èŠ‚æ•°:", font=("Microsoft YaHei", 12))
    num_chapters_label.grid(row=0, column=0, padx=5, pady=5, sticky="e")
    num_chapters_entry = ctk.CTkEntry(chapter_word_frame, textvariable=self.num_chapters_var, width=60, font=("Microsoft YaHei", 12))
    num_chapters_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")
    word_number_label = ctk.CTkLabel(chapter_word_frame, text="æ¯ç« å­—æ•°:", font=("Microsoft YaHei", 12))
    word_number_label.grid(row=0, column=2, padx=(15, 5), pady=5, sticky="e")
    word_number_entry = ctk.CTkEntry(chapter_word_frame, textvariable=self.word_number_var, width=60, font=("Microsoft YaHei", 12))
    word_number_entry.grid(row=0, column=3, padx=5, pady=5, sticky="w")

    # 4) ä¿å­˜è·¯å¾„
    row_fp = 3
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ä¿å­˜è·¯å¾„:", tooltip_key="filepath", row=row_fp, column=0, font=("Microsoft YaHei", 12))
    self.filepath_frame = ctk.CTkFrame(self.params_frame)
    self.filepath_frame.grid(row=row_fp, column=1, padx=5, pady=5, sticky="nsew")
    self.filepath_frame.columnconfigure(0, weight=1)
    filepath_entry = ctk.CTkEntry(self.filepath_frame, textvariable=self.filepath_var, font=("Microsoft YaHei", 12))
    filepath_entry.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
    browse_btn = ctk.CTkButton(self.filepath_frame, text="æµè§ˆ...", command=self.browse_folder, width=60, font=("Microsoft YaHei", 12))
    browse_btn.grid(row=0, column=1, padx=5, pady=5, sticky="e")

    # 5) ç« èŠ‚å·
    row_chap_num = 4
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ç« èŠ‚å·:", tooltip_key="chapter_num", row=row_chap_num, column=0, font=("Microsoft YaHei", 12))
    chapter_num_entry = ctk.CTkEntry(self.params_frame, textvariable=self.chapter_num_var, width=80, font=("Microsoft YaHei", 12))
    chapter_num_entry.grid(row=row_chap_num, column=1, padx=5, pady=5, sticky="w")

    # 6) å†…å®¹æŒ‡å¯¼
    row_user_guide = 5
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="å†…å®¹æŒ‡å¯¼:", tooltip_key="user_guidance", row=row_user_guide, column=0, font=("Microsoft YaHei", 12), sticky="ne")
    self.user_guide_text = ctk.CTkTextbox(self.params_frame, height=80, wrap="word", font=("Microsoft YaHei", 12))
    TextWidgetContextMenu(self.user_guide_text)
    self.user_guide_text.grid(row=row_user_guide, column=1, padx=5, pady=5, sticky="nsew")
    if hasattr(self, 'user_guidance_default') and self.user_guidance_default:
        self.user_guide_text.insert("0.0", self.user_guidance_default)

    # 7) å¯é€‰å…ƒç´ ï¼šæ ¸å¿ƒäººç‰©/å…³é”®é“å…·/ç©ºé—´åæ ‡/æ—¶é—´å‹åŠ›
    row_idx = 6
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="æ ¸å¿ƒäººç‰©:", tooltip_key="characters_involved", row=row_idx, column=0, font=("Microsoft YaHei", 12))
    
    # æ ¸å¿ƒäººç‰©è¾“å…¥æ¡†+æŒ‰é’®å®¹å™¨
    char_inv_frame = ctk.CTkFrame(self.params_frame)
    char_inv_frame.grid(row=row_idx, column=1, padx=5, pady=5, sticky="nsew")
    char_inv_frame.columnconfigure(0, weight=1)
    char_inv_frame.rowconfigure(0, weight=1)
    
    # ä¸‰è¡Œæ–‡æœ¬è¾“å…¥æ¡†
    self.char_inv_text = ctk.CTkTextbox(char_inv_frame, height=60, wrap="word", font=("Microsoft YaHei", 12))
    self.char_inv_text.grid(row=0, column=0, padx=(0,5), pady=5, sticky="nsew")
    if hasattr(self, 'characters_involved_var'):
        self.char_inv_text.insert("0.0", self.characters_involved_var.get())
    
    # å¯¼å…¥æŒ‰é’®
    import_btn = ctk.CTkButton(char_inv_frame, text="å¯¼å…¥", width=60, 
                             command=self.show_character_import_window,
                             font=("Microsoft YaHei", 12))
    import_btn.grid(row=0, column=1, padx=(0,5), pady=5, sticky="e")
    row_idx += 1
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="å…³é”®é“å…·:", tooltip_key="key_items", row=row_idx, column=0, font=("Microsoft YaHei", 12))
    key_items_entry = ctk.CTkEntry(self.params_frame, textvariable=self.key_items_var, font=("Microsoft YaHei", 12))
    key_items_entry.grid(row=row_idx, column=1, padx=5, pady=5, sticky="ew")
    row_idx += 1
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="ç©ºé—´åæ ‡:", tooltip_key="scene_location", row=row_idx, column=0, font=("Microsoft YaHei", 12))
    scene_loc_entry = ctk.CTkEntry(self.params_frame, textvariable=self.scene_location_var, font=("Microsoft YaHei", 12))
    scene_loc_entry.grid(row=row_idx, column=1, padx=5, pady=5, sticky="ew")
    row_idx += 1
    create_label_with_help_for_novel_params(self, parent=self.params_frame, label_text="æ—¶é—´å‹åŠ›:", tooltip_key="time_constraint", row=row_idx, column=0, font=("Microsoft YaHei", 12))
    time_const_entry = ctk.CTkEntry(self.params_frame, textvariable=self.time_constraint_var, font=("Microsoft YaHei", 12))
    time_const_entry.grid(row=row_idx, column=1, padx=5, pady=5, sticky="ew")

def build_optional_buttons_area(self, start_row=2):
    self.optional_btn_frame = ctk.CTkFrame(self.right_frame)
    self.optional_btn_frame.grid(row=start_row, column=0, sticky="ew", padx=5, pady=5)
    # é…ç½®åˆ—æƒé‡ï¼Œç¡®ä¿æŒ‰é’®å‡åŒ€åˆ†å¸ƒ
    self.optional_btn_frame.columnconfigure((0, 1, 2, 3, 4), weight=1)

    # ç¬¬ä¸€è¡Œç°æœ‰çš„æŒ‰é’® (ä¿æŒä¸å˜)
    self.btn_check_consistency = ctk.CTkButton(
        self.optional_btn_frame, text="ä¸€è‡´æ€§å®¡æ ¡", command=self.do_consistency_check, 
        font=("Microsoft YaHei", 12), width=100
    )
    self.btn_check_consistency.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    self.btn_import_knowledge = ctk.CTkButton(
        self.optional_btn_frame, text="å¯¼å…¥çŸ¥è¯†åº“", command=self.import_knowledge_handler,
        font=("Microsoft YaHei", 12), width=100
    )
    self.btn_import_knowledge.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

    self.btn_clear_vectorstore = ctk.CTkButton(
        self.optional_btn_frame, text="æ¸…ç©ºå‘é‡åº“", fg_color="red", 
        command=self.clear_vectorstore_handler, font=("Microsoft YaHei", 12), width=100
    )
    self.btn_clear_vectorstore.grid(row=0, column=2, padx=5, pady=5, sticky="ew")

    self.plot_arcs_btn = ctk.CTkButton(
        self.optional_btn_frame, text="æŸ¥çœ‹å‰§æƒ…è¦ç‚¹", command=self.show_plot_arcs_ui,
        font=("Microsoft YaHei", 12), width=100
    )
    self.plot_arcs_btn.grid(row=0, column=3, padx=5, pady=5, sticky="ew")

    self.role_library_btn = ctk.CTkButton(
        self.optional_btn_frame, text="è§’è‰²åº“", command=self.show_role_library,
        font=("Microsoft YaHei", 12), width=100
    )
    self.role_library_btn.grid(row=0, column=4, padx=5, pady=5, sticky="ew")

    # ä¼ç¬”åº“æŒ‰é’® (æ”¹ä¸º grid å¸ƒå±€ï¼Œä½ç½® 1,0)
    self.btn_foreshadow = ctk.CTkButton(
        self.optional_btn_frame, 
        text="ğŸ” æŸ¥çœ‹ä¼ç¬”åº“", 
        command=self.show_foreshadowing_records_ui,
        fg_color="#8E44AD", 
        font=("Microsoft YaHei", 12)
    )
    # å°† columnspan æ”¹ä¸º 2 æˆ– 3ï¼Œç•™å‡ºç©ºé—´ç»™æ–°æŒ‰é’®
    self.btn_foreshadow.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

    # === [æ–°å¢] å…¨ä¹¦é—®ç­”æŒ‰é’® ===
    self.btn_qa = ctk.CTkButton(
        self.optional_btn_frame, 
        text="ğŸ“š å…¨ä¹¦æ™ºèƒ½é—®ç­”", 
        command=self.show_novel_qa_ui, # ç»‘å®šåˆšæ‰å†™çš„å‡½æ•°
        fg_color="#16A085", # é’ç»¿è‰²ï¼ŒåŒºåˆ†åº¦é«˜
        font=("Microsoft YaHei", 12)
    )
    # æ”¾åœ¨ä¼ç¬”åº“æ—è¾¹
    self.btn_qa.grid(row=1, column=2, columnspan=3, padx=5, pady=5, sticky="ew")

def create_label_with_help_for_novel_params(self, parent, label_text, tooltip_key, row, column, font=None, sticky="e", padx=5, pady=5):
    frame = ctk.CTkFrame(parent)
    frame.grid(row=row, column=column, padx=padx, pady=pady, sticky=sticky)
    frame.columnconfigure(0, weight=0)
    label = ctk.CTkLabel(frame, text=label_text, font=font)
    label.pack(side="left")
    btn = ctk.CTkButton(frame, text="?", width=22, height=22, font=("Microsoft YaHei", 10),
                        command=lambda: messagebox.showinfo("å‚æ•°è¯´æ˜", tooltips.get(tooltip_key, "æš‚æ— è¯´æ˜")))
    btn.pack(side="left", padx=3)
    return frame
</file>

<file path="ui/role_library.py">
# ui/role_library.py
import os
import tkinter as tk
from tkinter import filedialog
import shutil
import re
import customtkinter as ctk
from tkinter import messagebox, BooleanVar
from customtkinter import CTkScrollableFrame, CTkTextbox, END
from utils import read_file, save_string_to_txt  # å¯¼å…¥ utils ä¸­çš„å‡½æ•°
from novel_generator.common import invoke_with_cleaning  # æ–°å¢å¯¼å…¥
from prompt_definitions import Character_Import_Prompt

DEFAULT_FONT = ("Microsoft YaHei", 12)

class RoleLibrary:
    def __init__(self, master, save_path, llm_adapter):  # æ–°å¢llm_adapterå‚æ•°
        self.master = master
        self.save_path = os.path.join(save_path, "è§’è‰²åº“")
        self.selected_category = None
        self.current_roles = []
        self.selected_del = []
        self.llm_adapter = llm_adapter  # ä¿å­˜LLMé€‚é…å™¨å®ä¾‹

        # åˆå§‹åŒ–çª—å£
        self.window = ctk.CTkToplevel(master)
        self.window.title("è§’è‰²åº“ç®¡ç†")
        self.window.geometry("1200x800")
        self.window.protocol("WM_DELETE_WINDOW", self.on_close)

        # åˆ›å»ºç›®å½•ç»“æ„
        self.create_library_structure()
        # æ„å»ºUI
        self.create_ui()
        # çª—å£å±…ä¸­
        self.center_window()
        # çª—å£æ¨¡æ€è®¾ç½®
        self.window.grab_set()
        self.window.attributes('-topmost', 1)
        self.window.after(200, lambda: self.window.attributes('-topmost', 0))

    def create_library_structure(self):
        """åˆ›å»ºå¿…è¦çš„ç›®å½•ç»“æ„"""
        os.makedirs(self.save_path, exist_ok=True)
        all_dir = os.path.join(self.save_path, "å…¨éƒ¨")
        os.makedirs(all_dir, exist_ok=True)

    def create_ui(self):
        """åˆ›å»ºä¸»ç•Œé¢"""
        # åˆ†ç±»æŒ‰é’®åŒº
        self.create_category_bar()

        # ä¸»å†…å®¹åŒº
        main_frame = ctk.CTkFrame(self.window)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # å·¦ä¾§é¢æ¿ï¼ˆä¿æŒä¸å˜ï¼‰
        left_panel = ctk.CTkFrame(main_frame, width=300)
        left_panel.pack(side="left", fill="both", padx=5, pady=5)

        # ä¸Šéƒ¨è§’è‰²åˆ—è¡¨åŒºï¼ˆä¿æŒä¸å˜ï¼‰
        role_list_container = ctk.CTkFrame(left_panel)
        role_list_container.pack(fill="both", expand=True, pady=(0, 5))

        self.role_list_frame = ctk.CTkScrollableFrame(role_list_container)
        self.role_list_frame.pack(fill="both", expand=True)

        # ä¸‹éƒ¨å†…å®¹é¢„è§ˆåŒºï¼ˆä¿æŒä¸å˜ï¼‰
        preview_container = ctk.CTkFrame(left_panel)
        preview_container.pack(fill="both", expand=True, pady=(5, 0))

        self.preview_text = ctk.CTkTextbox(preview_container, wrap="word",
                                            font=("Microsoft YaHei", 12))
        scrollbar = ctk.CTkScrollbar(
            preview_container, command=self.preview_text.yview)
        self.preview_text.configure(yscrollcommand=scrollbar.set)

        self.preview_text.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # å³ä¾§é¢æ¿ï¼ˆä¿¡æ¯ç¼–è¾‘åŒºï¼‰
        right_panel = ctk.CTkFrame(main_frame)
        right_panel.pack(side="right", fill="both", expand=True, padx=5, pady=5)

        # åˆ†ç±»é€‰æ‹©è¡Œ
        category_frame = ctk.CTkFrame(right_panel)
        category_frame.pack(fill="x", padx=5, pady=5)

        # åˆ†ç±»é€‰æ‹©æ ‡ç­¾
        ctk.CTkLabel(category_frame, text="åˆ†ç±»é€‰æ‹©", font=DEFAULT_FONT).pack(side="left", padx=(0, 5))

        # åˆ†ç±»é€‰æ‹©æ¡†
        self.category_combobox = ctk.CTkComboBox(
            category_frame,
            values=self._get_all_categories(),
            width=200,
            font=DEFAULT_FONT
        )
        self.category_combobox.pack(side="left", padx=0)

        # åˆ†ç±»ä¿å­˜æŒ‰é’®
        self.save_category_btn = ctk.CTkButton(
            category_frame,
            text="ä¿å­˜åˆ†ç±»",
            width=80,
            command=self._move_to_category,
            font=DEFAULT_FONT
        )
        self.save_category_btn.pack(side="left", padx=(0, 5))

        # æ‰“å¼€æ–‡ä»¶å¤¹æŒ‰é’®
        ctk.CTkButton(
            category_frame,
            text="æ‰“å¼€æ–‡ä»¶å¤¹",
            width=80,
            command=lambda: os.startfile(
                os.path.join(self.save_path, self.category_combobox.get())),
            font=DEFAULT_FONT
        ).pack(side="left", padx=0)

        # è§’è‰²åç¼–è¾‘è¡Œ
        name_frame = ctk.CTkFrame(right_panel)
        name_frame.pack(fill="x", padx=5, pady=5)

        # è§’è‰²åç§°æ ‡ç­¾
        ctk.CTkLabel(name_frame, text="è§’è‰²åç§°", font=DEFAULT_FONT).pack(side="left", padx=(0, 5))

        self.role_name_var = tk.StringVar()
        self.role_name_entry = ctk.CTkEntry(
            name_frame,
            textvariable=self.role_name_var,
            placeholder_text="è§’è‰²åç§°",
            width=200,
            font=DEFAULT_FONT
        )
        self.role_name_entry.pack(side="left", padx=0)

        ctk.CTkButton(
            name_frame,
            text="ä¿®æ”¹",
            width=60,
            command=self._rename_role_file,
            font=DEFAULT_FONT
        ).pack(side="left", padx=(0, 5))

        ctk.CTkButton(
            name_frame,
            text="æ–°å¢",
            width=60,
            command=lambda: self._create_new_role("å…¨éƒ¨"),
            font=DEFAULT_FONT
        ).pack(side="left", padx=0)

        # å±æ€§ç¼–è¾‘åŒºï¼ˆåŸºç¡€æ¡†æ¶ï¼‰
        self.attributes_frame = ctk.CTkScrollableFrame(right_panel)
        self.attributes_frame.pack(fill="both", expand=True, padx=5, pady=5)
        # è®¾ç½®ç»Ÿä¸€çš„åˆ—æƒé‡
        self.attributes_frame.grid_columnconfigure(1, weight=1)

        button_frame = ctk.CTkFrame(right_panel)
        button_frame.pack(fill="x", padx=5, pady=5)

        ctk.CTkButton(button_frame, text="å¯¼å…¥è§’è‰²",
                      command=self.import_roles, font=DEFAULT_FONT).pack(side="left", padx=5)
        ctk.CTkButton(button_frame, text="åˆ é™¤",
                      command=self.delete_current_role, font=DEFAULT_FONT).pack(side="left", padx=5)
        ctk.CTkButton(button_frame, text="ä¿å­˜",
                      command=self.save_current_role, font=DEFAULT_FONT).pack(side="left", padx=5)

    def _get_all_categories(self):
        """è·å–æ‰€æœ‰æœ‰æ•ˆåˆ†ç±»ï¼ˆåŒ…æ‹¬åŠ¨æ€æ›´æ–°ï¼‰"""
        categories = ["å…¨éƒ¨"]
        for d in os.listdir(self.save_path):
            if os.path.isdir(os.path.join(self.save_path, d)) and d != "å…¨éƒ¨":
                categories.append(d)
        return categories

    def _move_to_category(self):
        """åˆ†ç±»è½¬ç§»åŠŸèƒ½"""
        if not hasattr(self, 'current_role') or not self.current_role:
            self._show_message("warning", "è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²")
            return

        new_category = self.category_combobox.get()
        
        # å¦‚æœå½“å‰åœ¨"å…¨éƒ¨"åˆ†ç±»ä¸‹ï¼Œéœ€è¦æ‰¾åˆ°è§’è‰²å®é™…æ‰€åœ¨åˆ†ç±»
        if self.selected_category == "å…¨éƒ¨":
            # éå†æ‰€æœ‰åˆ†ç±»æŸ¥æ‰¾å®é™…å­˜å‚¨ä½ç½®ï¼ˆåŒ…å«å…¨éƒ¨ç›®å½•ï¼‰
            actual_category = None
            for category in os.listdir(self.save_path):
                test_path = os.path.join(
                    self.save_path, category, f"{self.current_role}.txt")
                if os.path.exists(test_path):
                    actual_category = category
                    break

            if not actual_category:
                self._show_message("error", "é”™è¯¯", f"æ‰¾ä¸åˆ°è§’è‰² {self.current_role} çš„å®é™…å­˜å‚¨ä½ç½®")
                return

            old_path = os.path.join(
                self.save_path, actual_category, f"{self.current_role}.txt")
        else:
            old_path = os.path.join(
                self.save_path, self.selected_category, f"{self.current_role}.txt")

        # å¦‚æœç›®æ ‡åˆ†ç±»æ˜¯"å…¨éƒ¨"ï¼Œåˆ™å®é™…ç§»åŠ¨åˆ°"å…¨éƒ¨"åˆ†ç±»
        if new_category == "å…¨éƒ¨":
            new_path = os.path.join(
                self.save_path, "å…¨éƒ¨", f"{self.current_role}.txt")
        else:
            new_path = os.path.join(
                self.save_path, new_category, f"{self.current_role}.txt")

        # æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨ç›®æ ‡åˆ†ç±»
        if os.path.exists(new_path):
            self._show_message("info", "æç¤º", "è§’è‰²å·²åœ¨ç›®æ ‡åˆ†ç±»ä¸­")
            return

        confirm = messagebox.askyesno(
            "ç¡®è®¤", f"ç¡®å®šè¦å°†è§’è‰² {self.current_role} ç§»åŠ¨åˆ° {new_category} åˆ†ç±»å—ï¼Ÿ", parent=self.window)
        if not confirm:
            return

        try:
            # ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
            os.makedirs(os.path.dirname(new_path), exist_ok=True)
            
            try:
                # æ‰§è¡Œç§»åŠ¨æ“ä½œ
                shutil.move(old_path, new_path)
                
                # æ›´æ–°æ˜¾ç¤º
                self.selected_category = new_category if new_category != "å…¨éƒ¨" else "å…¨éƒ¨"
                self.show_category(self.selected_category)
                self.category_combobox.set(new_category)
                
                # æˆåŠŸæç¤º
                messagebox.showinfo("æˆåŠŸ", "åˆ†ç±»å·²æ›´æ–°", parent=self.window)
                return  # æˆåŠŸæ—¶ç›´æ¥è¿”å›
                
            except Exception as e:
                # å¤±è´¥æ—¶æ¢å¤åŸåˆ†ç±»æ˜¾ç¤º
                self.category_combobox.set(self.selected_category)
                raise e
        except Exception as e:
            self._show_message("error", "é”™è¯¯", f"åˆ†ç±»è½¬ç§»å¤±è´¥ï¼š{str(e)}")
            self.category_combobox.set(self.selected_category)

    def import_roles(self):
        """å¯¼å…¥è§’è‰²çª—å£"""
        import_window = ctk.CTkToplevel(self.window)
        import_window.title("è§’è‰²å¯¼å…¥")
        import_window.geometry("800x600")
        import_window.transient(self.window)  # è®¾ç½®ä¸ºå­çª—å£
        import_window.grab_set()  # æ¨¡æ€çª—å£
        import_window.lift()  # ç½®äºçˆ¶çª—å£å‰é¢

        # çª—å£å±…ä¸­è®¡ç®—
        import_window.update_idletasks()
        i_width = import_window.winfo_width()
        i_height = import_window.winfo_height()
        x = self.window.winfo_x() + (self.window.winfo_width() - i_width) // 2
        y = self.window.winfo_y() + (self.window.winfo_height() - i_height) // 2
        import_window.geometry(f"+{x}+{y}")

        # ä¸»å†…å®¹åŒº
        main_frame = ctk.CTkFrame(import_window)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # å·¦å³é¢æ¿å®¹å™¨
        content_frame = ctk.CTkFrame(main_frame)
        content_frame.pack(fill="both", expand=True, pady=(0, 10))
        content_frame.grid_columnconfigure(0, weight=1)  # å·¦ä¾§é¢æ¿æƒé‡
        content_frame.grid_columnconfigure(1, weight=1)  # å³ä¾§é¢æ¿æƒé‡

        # å·¦ä¾§é¢æ¿ - ä½¿ç”¨æƒé‡è®©æ§ä»¶å æ»¡ç©ºé—´
        left_panel = ctk.CTkFrame(content_frame)
        left_panel.grid(row=0, column=0, sticky="nsew", padx=(0, 5), pady=5)
        left_panel.grid_rowconfigure(0, weight=1)
        left_panel.grid_columnconfigure(0, weight=1)
        left_panel.grid_propagate(False)  # é˜²æ­¢å­æ§ä»¶æ”¹å˜çˆ¶å®¹å™¨å¤§å°

        # å³ä¾§é¢æ¿ï¼ˆ2ä»½å®½åº¦ï¼‰ - æ·»åŠ åˆå§‹å¯ç¼–è¾‘æ–‡æœ¬æ¡†
        right_panel = ctk.CTkFrame(content_frame)
        right_panel.grid(row=0, column=1, sticky="nsew", padx=(5, 0), pady=5)
        right_panel.grid_rowconfigure(0, weight=1)
        right_panel.grid_columnconfigure(0, weight=1)
        
        # åˆ›å»ºåˆå§‹å¯ç¼–è¾‘æ–‡æœ¬æ¡†
        text_box = ctk.CTkTextbox(right_panel, wrap="word", font=DEFAULT_FONT)
        text_box.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        text_box.configure(state="normal")  # ä¿æŒå¯ç¼–è¾‘çŠ¶æ€

        # åˆå§‹åŒ–è§’è‰²åˆ—è¡¨
        self.import_roles_list = []

        # åº•éƒ¨æŒ‰é’®åŒº
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack(fill="x", pady=(0, 10))

        # å¯¼å…¥æŒ‰é’®
        ctk.CTkButton(
            btn_frame,
            text="å¯¼å…¥ä¸´æ—¶è§’è‰²åº“",
            width=120,
            command=lambda: self.confirm_import(import_window),
            font=DEFAULT_FONT
        ).pack(side="left", padx=10)

        # åˆ†ææ–‡ä»¶æŒ‰é’®
        ctk.CTkButton(
            btn_frame,
            text="åˆ†ææ–‡ä»¶",
            width=100,
            command=lambda: self.analyze_character_state(right_panel, left_panel),
            font=DEFAULT_FONT
        ).pack(side="left", padx=10)

        # åŠ è½½character_state.txtæŒ‰é’®
        ctk.CTkButton(
            btn_frame,
            text="åŠ è½½character_state.txt",
            width=160,
            command=lambda: self.load_default_character_state(right_panel),
            font=DEFAULT_FONT
        ).pack(side="right", padx=10)

        # ä»æ–‡ä»¶å¯¼å…¥æŒ‰é’®
        ctk.CTkButton(
            btn_frame,
            text="ä»æ–‡ä»¶å¯¼å…¥",
            width=100,
            command=lambda: self.import_from_file(right_panel),
            font=DEFAULT_FONT
        ).pack(side="right", padx=10)

        # è®¾ç½®å†…å®¹åŒºæƒé‡
        content_frame.grid_rowconfigure(0, weight=1)

    def analyze_character_state(self, right_panel, left_panel):
        """åˆ†æè§’è‰²çŠ¶æ€æ–‡ä»¶ï¼Œä½¿ç”¨LLMæå–è§’è‰²ä¿¡æ¯å¹¶ä¿å­˜åˆ°ä¸´æ—¶è§’è‰²åº“"""
        content = ""
        for widget in right_panel.winfo_children():
            if isinstance(widget, ctk.CTkTextbox):
                content = widget.get("1.0", "end").strip()
                break
        
        if not content:
            messagebox.showwarning("è­¦å‘Š", "æœªæ‰¾åˆ°å¯åˆ†æçš„å†…å®¹", parent=self.window)
            return

        try:
            # åˆ›å»ºä¸´æ—¶è§’è‰²åº“ç›®å½•
            target_dir = os.path.join(self.save_path, "ä¸´æ—¶è§’è‰²åº“")
            # æ¸…ç©ºç°æœ‰ä¸´æ—¶è§’è‰²åº“
            if os.path.exists(target_dir):
                for filename in os.listdir(target_dir):
                    file_path = os.path.join(target_dir, filename)
                    try:
                        if os.path.isfile(file_path):
                            os.unlink(file_path)
                    except Exception as e:
                        print(f"åˆ é™¤æ–‡ä»¶{file_path}æ—¶å‡ºé”™: {e}")
            os.makedirs(target_dir, exist_ok=True)

            # è°ƒç”¨LLMè¿›è¡Œåˆ†æ
            prompt = f"{Character_Import_Prompt}\n<<å¾…åˆ†æå°è¯´æ–‡æœ¬å¼€å§‹>>\n{content}\n<<å¾…åˆ†æå°è¯´æ–‡æœ¬ç»“æŸ>>"
            response = invoke_with_cleaning(
                self.llm_adapter,
                prompt
            )
            
            # è§£æLLMå“åº”
            roles = self._parse_llm_response(response)
            
            if not roles:
                messagebox.showwarning("è­¦å‘Š", "æœªè§£æåˆ°æœ‰æ•ˆè§’è‰²ä¿¡æ¯", parent=self.window)
                return

            # ç›´æ¥æ˜¾ç¤ºåˆ†æç»“æœè€Œä¸ä¿å­˜åˆ°æ–‡ä»¶
            self._display_analyzed_roles(left_panel, roles)

        except Exception as e:
            messagebox.showerror("åˆ†æå¤±è´¥", f"LLMåˆ†æå‡ºé”™ï¼š{str(e)}", parent=self.window)

    def _display_temp_roles(self, parent, temp_dir):
        """æ˜¾ç¤ºä¸´æ—¶è§’è‰²åº“ä¸­çš„è§’è‰²"""
        # æ¸…ç©ºå·¦ä¾§é¢æ¿
        for widget in parent.winfo_children():
            widget.destroy()

        # åˆ›å»ºæ»šåŠ¨å®¹å™¨
        scroll_frame = ctk.CTkScrollableFrame(parent)
        scroll_frame.pack(fill="both", expand=True)

        # è¯»å–æ‰€æœ‰ä¸´æ—¶è§’è‰²æ–‡ä»¶
        self.character_checkboxes = {}
        for file_name in os.listdir(temp_dir):
            if file_name.endswith(".txt"):
                role_name = os.path.splitext(file_name)[0]
                file_path = os.path.join(temp_dir, file_name)
                
                # è§£æè§’è‰²å±æ€§
                attributes = self._parse_temp_role_file(file_path)
                
                # åˆ›å»ºå¸¦å‹¾é€‰æ¡†çš„æ¡ç›®
                frame = ctk.CTkFrame(scroll_frame)
                frame.pack(fill="x", pady=2, padx=5)
                
                # å‹¾é€‰æ¡†
                var = BooleanVar(value=True)
                cb = ctk.CTkCheckBox(frame, text="", variable=var, width=20, font=DEFAULT_FONT)
                cb.pack(side="left", padx=5)
                
                # è§’è‰²åç§°
                lbl = ctk.CTkLabel(frame, text=role_name, 
                                 font=("Microsoft YaHei", 12))
                lbl.pack(side="left", padx=5)
                
                # å±æ€§æ‘˜è¦
                attrs = [f"{k}({len(v)})" for k,v in attributes.items()]
                summary = ctk.CTkLabel(frame, text=" | ".join(attrs), 
                                     font=("Microsoft YaHei", 12),
                                     text_color="gray")
                summary.pack(side="right", padx=10)
                
                self.character_checkboxes[role_name] = {
                    'var': var,
                    'data': {'name': role_name, 'attributes': attributes}
                }

        # æ·»åŠ æ“ä½œæŒ‰é’®
        btn_frame = ctk.CTkFrame(scroll_frame)
        btn_frame.pack(fill="x", pady=5)
        ctk.CTkButton(btn_frame, text="å…¨é€‰", 
                     command=lambda: self._toggle_all(True), font=DEFAULT_FONT).pack(side="left")
        ctk.CTkButton(btn_frame, text="å–æ¶ˆé€‰æ‹©", 
                     command=lambda: self._toggle_all(False), font=DEFAULT_FONT).pack(side="left")

    def _parse_temp_role_file(self, file_path):
        """è§£æä¸´æ—¶è§’è‰²æ–‡ä»¶"""
        attributes = {}
        current_attr = None
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # ç»Ÿä¸€è§£æâ”œâ”€â”€å’Œâ””â”€â”€ä¸¤ç§å‰ç¼€
                    if any(prefix in line for prefix in ['â”œâ”€â”€', 'â””â”€â”€']) and 'ï¼š' in line:
                        prefix = 'â”œâ”€â”€' if 'â”œâ”€â”€' in line else 'â””â”€â”€'
                        current_attr = line.split(prefix)[1].split('ï¼š')[0].strip()
                        attributes[current_attr] = []
                    elif any(prefix in line for prefix in ['â”‚  â”œâ”€â”€', 'â”‚  â””â”€â”€']):
                        prefix = 'â”‚  â”œâ”€â”€' if 'â”‚  â”œâ”€â”€' in line else 'â”‚  â””â”€â”€'
                        if current_attr:
                            item = line.split(prefix)[1].strip()
                            attributes[current_attr].append(item)
        except Exception as e:
            messagebox.showerror("è§£æé”™è¯¯", f"è§£æä¸´æ—¶æ–‡ä»¶å¤±è´¥ï¼š{str(e)}", parent=self.window)
        return attributes

    def _parse_llm_response(self, response):
        """è§£æLLMè¿”å›çš„è§’è‰²æ•°æ®"""
        roles = []
        current_role = None
        current_attr = None
        current_subattr = None
        
        attribute_pattern = re.compile(r'^([â”œâ””]â”€â”€)([\w\u4e00-\u9fa5]+)\s*[:ï¼š]')
        item_pattern = re.compile(r'^â”‚\s+([â”œâ””]â”€â”€)\s*(.*)')
        
        for line in response.split('\n'):
            line = line.rstrip()
            
            # æ£€æµ‹è§’è‰²åç§°è¡Œï¼ˆå…¼å®¹ä¸­è‹±æ–‡å†’å·å’Œå‰åç©ºæ ¼ï¼‰
            role_match = re.match(r'^\s*([\u4e00-\u9fa5a-zA-Z0-9]+)\s*[:ï¼š]\s*$', line)
            if role_match:
                current_role = role_match.group(1).strip()
                roles.append({'name': current_role, 'attributes': {}})
                continue
                
            if not current_role:
                continue
                
            # è§£æå±æ€§ï¼ˆæ”¯æŒå­å±æ€§ï¼‰
            attr_match = attribute_pattern.match(line)
            if attr_match:
                prefix, attr_name = attr_match.groups()
                current_attr = attr_name.strip()
                roles[-1]['attributes'][current_attr] = []
                current_subattr = None
                continue
                
            # è§£æå±æ€§æ¡ç›®ï¼ˆæ”¯æŒå¤šçº§ç»“æ„ï¼‰
            item_match = item_pattern.match(line)
            if item_match and current_attr:
                prefix, content = item_match.groups()
                content = content.strip()
                
                # è§£æå­å±æ€§ï¼ˆä¾‹å¦‚"èº«ä½“çŠ¶æ€: xxx"ï¼‰
                if ':' in content or 'ï¼š' in content:
                    subattr_match = re.split(r'[:ï¼š]', content, 1)
                    if len(subattr_match) > 1:
                        current_subattr = subattr_match[0].strip()
                        value = subattr_match[1].strip()
                        if value:  # å€¼ä¸ä¸ºç©ºæ—¶æ‰æ·»åŠ 
                            roles[-1]['attributes'][current_attr].append(
                                f"{current_subattr}: {value}"
                            )
                        continue
                
                # æ™®é€šæ¡ç›®å¤„ç†
                if content:
                    if current_subattr:
                        # å­å±æ€§çš„å»¶ç»­æ¡ç›®
                        roles[-1]['attributes'][current_attr][-1] += f"ï¼Œ{content}"
                    else:
                        roles[-1]['attributes'][current_attr].append(content)
        return roles

    def _display_analyzed_roles(self, parent, roles):
        """æ˜¾ç¤ºåˆ†æåçš„è§’è‰²åˆ—è¡¨"""
        self.character_checkboxes = {}
        
        # åˆ›å»ºå¸¦æ»šåŠ¨æ¡çš„å®¹å™¨
        scroll_frame = ctk.CTkScrollableFrame(parent)
        scroll_frame.pack(fill="both", expand=True, padx=5, pady=5)
        scroll_frame.grid_rowconfigure(0, weight=1)
        scroll_frame.grid_columnconfigure(0, weight=1)

        # ä¸ºæ¯ä¸ªè§’è‰²åˆ›å»ºå¸¦å‹¾é€‰æ¡†çš„æ¡ç›®
        for role in roles:
            frame = ctk.CTkFrame(scroll_frame)
            frame.pack(fill="x", pady=2, padx=5)
            
            # å‹¾é€‰æ¡†
            var = BooleanVar(value=True)
            cb = ctk.CTkCheckBox(frame, text="", variable=var, width=20, font=DEFAULT_FONT)
            cb.pack(side="left", padx=5)
            
            # è§’è‰²åç§°æ ‡ç­¾
            lbl = ctk.CTkLabel(frame, text=role['name'], 
                             font=("Microsoft YaHei", 12))
            lbl.pack(side="left", padx=5)
            
            # å±æ€§æ‘˜è¦
            attrs = [f"{k}({len(v)})" for k,v in role['attributes'].items()]
            summary = ctk.CTkLabel(frame, text=" | ".join(attrs), 
                                 font=("Microsoft YaHei", 12),
                                 text_color="gray")
            summary.pack(side="right", padx=10)
            
            self.character_checkboxes[role['name']] = {
                'var': var,
                'data': role
            }

        # æ·»åŠ å…¨é€‰/åé€‰æŒ‰é’®
        btn_frame = ctk.CTkFrame(scroll_frame)
        btn_frame.pack(fill="x", pady=5)
        
        ctk.CTkButton(btn_frame, text="å…¨é€‰", 
                     command=lambda: self._toggle_all(True), font=DEFAULT_FONT).pack(side="left")
        ctk.CTkButton(btn_frame, text="åé€‰", 
                     command=lambda: self._toggle_all(False), font=DEFAULT_FONT).pack(side="left")

    def _toggle_all(self, select):
        """å…¨é€‰/åé€‰æ“ä½œ"""
        for role in self.character_checkboxes.values():
            current_state = role['var'].get()
            # å¦‚æœæ˜¯åé€‰æ“ä½œï¼Œåˆ™è®¾ç½®ç›¸åçŠ¶æ€
            if isinstance(select, bool):
                role['var'].set(select)
            else:
                role['var'].set(not current_state)


    def import_from_file(self, right_panel):
        """ä»æ–‡ä»¶å¯¼å…¥å†…å®¹åˆ°å³ä¾§çª—å£"""
        filetypes = (
            ('æ–‡æœ¬æ–‡ä»¶', '*.txt'),
            ('Wordæ–‡æ¡£', '*.docx'),
            ('æ‰€æœ‰æ–‡ä»¶', '*.*')
        )
        
        file_path = filedialog.askopenfilename(
            title="é€‰æ‹©è¦å¯¼å…¥çš„æ–‡ä»¶",
            initialdir=os.path.expanduser("~"),
            filetypes=filetypes
        )
        
        if not file_path:
            return

        try:
            content = ""
            if file_path.endswith('.docx'):
                # å¤„ç†Wordæ–‡æ¡£
                from docx import Document
                doc = Document(file_path)
                content = "\n".join([para.text for para in doc.paragraphs])
            else:
                # å¤„ç†æ™®é€šæ–‡æœ¬æ–‡ä»¶
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()

            # æ›´æ–°å³ä¾§æ–‡æœ¬æ¡†ä¸­
            for widget in right_panel.winfo_children():
                if isinstance(widget, ctk.CTkTextbox):
                    widget.delete("1.0", "end")
                    widget.insert("1.0", content)
                    break

        except Exception as e:
            messagebox.showerror("å¯¼å…¥å¤±è´¥", f"æ— æ³•è¯»å–æ–‡ä»¶ï¼š{str(e)}", parent=self.window)

    def load_default_character_state(self, right_panel):
        """åŠ è½½character_state.txtæ–‡ä»¶åˆ°å³ä¾§çª—å£"""
        # è·å–ä¿å­˜è·¯å¾„
        save_path = os.path.dirname(self.save_path)
        file_path = os.path.join(save_path, "character_state.txt")

        if not os.path.exists(file_path):
            messagebox.showwarning("è­¦å‘Š", f"æœªæ‰¾åˆ°æ–‡ä»¶: {file_path}", parent=self.window)
            return

        try:
            # è¯»å–æ–‡ä»¶å†…å®¹
            content = read_file(file_path)

            # æ¸…ç©ºå³ä¾§é¢æ¿ä¸­å¯èƒ½å­˜åœ¨çš„æ—§æ§ä»¶
            for widget in right_panel.winfo_children():
                widget.destroy()

            # æŸ¥æ‰¾æˆ–åˆ›å»ºæ–‡æœ¬æ¡†
            text_box = None
            for widget in right_panel.winfo_children():
                if isinstance(widget, ctk.CTkTextbox):
                    text_box = widget
                    break
            
            if not text_box:
                text_box = ctk.CTkTextbox(right_panel, wrap="word", font=DEFAULT_FONT)
                text_box.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
            
            text_box.configure(state="normal")
            text_box.delete("1.0", "end")
            text_box.insert("1.0", content)

            # è®¾ç½®å³è¾¹é¢æ¿çš„å¸ƒå±€æƒé‡
            right_panel.grid_rowconfigure(0, weight=1)
            right_panel.grid_columnconfigure(0, weight=1)

        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"åŠ è½½æ–‡ä»¶å¤±è´¥: {str(e)}", parent=self.window)

    def confirm_import(self, import_window):
        """ä»ä¸´æ—¶è§’è‰²åº“å¯¼å…¥é€‰ä¸­çš„è§’è‰²"""
        # åˆ›å»ºå¿…è¦çš„ç›®å½•
        target_dir = os.path.join(self.save_path, "ä¸´æ—¶è§’è‰²åº“")
        os.makedirs(target_dir, exist_ok=True)
        
        try:
            # è·å–é€‰ä¸­çš„è§’è‰²
            selected_roles = [role_data['data'] for role_data in self.character_checkboxes.values() 
                            if role_data['var'].get()]
            
            if not selected_roles:
                # åˆ›å»ºé”™è¯¯æç¤ºçª—å£
                error_window = ctk.CTkToplevel(import_window)
                error_window.title("é”™è¯¯")
                error_window.transient(import_window)
                error_window.grab_set()
                
                # çª—å£å†…å®¹
                ctk.CTkLabel(error_window, text="è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªè§’è‰²", font=DEFAULT_FONT).pack(padx=20, pady=10)
                ctk.CTkButton(error_window, text="ç¡®å®š", command=error_window.destroy, font=DEFAULT_FONT).pack(pady=10)
                
                # çª—å£å±…ä¸­
                error_window.update_idletasks()
                e_width = error_window.winfo_width()
                e_height = error_window.winfo_height()
                x = import_window.winfo_x() + (import_window.winfo_width() - e_width) // 2
                y = import_window.winfo_y() + (import_window.winfo_height() - e_height) // 2
                error_window.geometry(f"+{x}+{y}")
                error_window.attributes('-topmost', 1)
                return

            # ä»å†…å­˜æ•°æ®ç›´æ¥ä¿å­˜è§’è‰²
            for role in selected_roles:
                dest_path = os.path.join(target_dir, f"{role['name']}.txt")
                
                # æ„å»ºè§’è‰²å†…å®¹
                content_lines = [f"{role['name']}ï¼š"]
                for attr, items in role['attributes'].items():
                    content_lines.append(f"â”œâ”€â”€{attr}ï¼š")
                    for i, item in enumerate(items):
                        prefix = "â”œâ”€â”€" if i < len(items)-1 else "â””â”€â”€"
                        content_lines.append(f"â”‚  {prefix}{item}")
                
                # ç›´æ¥å†™å…¥æ–‡ä»¶ï¼Œè¦†ç›–å·²å­˜åœ¨çš„æ–‡ä»¶
                with open(dest_path, 'w', encoding='utf-8') as f:
                    f.write('\n'.join(content_lines))

            # åˆ·æ–°åˆ†ç±»æ˜¾ç¤º
            self.load_categories()
            import_window.destroy()
            
        except Exception as e:
            # é™é»˜å¤„ç†é”™è¯¯
            import_window.destroy()



    def delete_current_role(self):
        """åˆ é™¤å½“å‰è§’è‰²"""
        if not hasattr(self, 'current_role') or not self.current_role:
            return

        confirm = messagebox.askyesno(
            "ç¡®è®¤åˆ é™¤", f"ç¡®å®šè¦åˆ é™¤è§’è‰² {self.current_role} å—ï¼Ÿ", parent=self.window)
        if not confirm:
            return

        role_path = os.path.join(
            self.save_path, self.selected_category, f"{self.current_role}.txt")
        try:
            os.remove(role_path)
            # ä»"å…¨éƒ¨"åˆ†ç±»ä¹Ÿåˆ é™¤
            all_path = os.path.join(
                self.save_path, "å…¨éƒ¨", f"{self.current_role}.txt")
            if os.path.exists(all_path):
                os.remove(all_path)
            self.show_category(self.selected_category)
            self.preview_text.delete("1.0", "end")
            self._show_message("info", "æˆåŠŸ", "è§’è‰²å·²åˆ é™¤")
        except Exception as e:
            self._show_message("error", "é”™è¯¯", f"åˆ é™¤å¤±è´¥ï¼š{str(e)}")

    def _build_role_content(self):
        """æ„å»ºè§’è‰²æ–‡ä»¶å†…å®¹"""
        content = [f"{self.role_name_var.get()}ï¼š"]
        attributes_order = ["ç‰©å“", "èƒ½åŠ›", "çŠ¶æ€", "ä¸»è¦è§’è‰²é—´å…³ç³»ç½‘", "è§¦å‘æˆ–åŠ æ·±çš„äº‹ä»¶"]

        for attr_name in attributes_order:
            content.append(f"â”œâ”€â”€{attr_name}ï¼š")
            # æ‰¾åˆ°å¯¹åº”çš„ attribute_block
            for block in self.attributes_frame.winfo_children():
                if isinstance(block, ctk.CTkFrame) and block.attribute_name == attr_name:
                    # éå†è¯¥ block ä¸­çš„æ‰€æœ‰ CTkEntry
                    for child in block.winfo_children():
                        if isinstance(child, ctk.CTkFrame):  # æ¡ç›®è¡Œ
                            for item in child.winfo_children():
                                if isinstance(item, ctk.CTkEntry):
                                    entry_text = item.get().strip()
                                    if entry_text:  # åªæ·»åŠ éç©ºæ¡ç›®
                                        content.append(f"â”‚  â”œâ”€â”€{entry_text}")
                    break  # æ‰¾åˆ°å¯¹åº”å±æ€§åè·³å‡ºå¾ªç¯
        return content
    
    def _show_message(self, kind: str, title: str, text: str):
        """
        ç»Ÿä¸€æ˜¾ç¤º messagebox å¹¶ç¡®ä¿æ¶ˆæ¯å¼¹çª—ä½äºé¡¶å±‚ã€‚
        kind: "info" | "warning" | "error"
        """
        try:
            # å…ˆæŠŠçˆ¶çª—å£ç½®é¡¶ï¼Œä¿è¯ messagebox è¦†ç›–åœ¨ä¸Šé¢
            self.window.attributes('-topmost', 1)
        except Exception:
            pass

        if kind == "info":
            messagebox.showinfo(title, text, parent=self.window)
        elif kind == "warning":
            messagebox.showwarning(title, text, parent=self.window)
        elif kind == "error":
            messagebox.showerror(title, text, parent=self.window)
        else:
            messagebox.showinfo(title, text, parent=self.window)

        # å»¶è¿Ÿä¸€ç‚¹å†æ¢å¤çˆ¶çª—å£çš„ topmostï¼Œä»¥ç¡®ä¿ messagebox å·²æ˜¾ç¤º
        try:
            self.window.after(200, lambda: self.window.attributes('-topmost', 0))
        except Exception:
            pass

    def _save_role_file(self, content, save_path):
        """ä¿å­˜è§’è‰²æ–‡ä»¶"""
        with open(save_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(content))

    def _check_role_name_conflict(self, new_name):
        """æ£€æŸ¥è§’è‰²åæ˜¯å¦é‡å¤ï¼Œéå†æ•´ä¸ªè§’è‰²æ–‡ä»¶å¤¹"""
        conflicts = []
        # éå†æ‰€æœ‰åˆ†ç±»ç›®å½•
        for category in os.listdir(self.save_path):
            if os.path.isdir(os.path.join(self.save_path, category)):
                # æ£€æŸ¥è¯¥åˆ†ç±»ä¸‹æ˜¯å¦æœ‰åŒåè§’è‰²
                role_path = os.path.join(
                    self.save_path, category, f"{new_name}.txt")
                if os.path.exists(role_path):
                    # å¦‚æœæ˜¯"å…¨éƒ¨"åˆ†ç±»ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥æ˜¯å¦æ˜¯å®é™…æ–‡ä»¶
                    if category == "å…¨éƒ¨":
                        # æ£€æŸ¥"å…¨éƒ¨"ç›®å½•ä¸‹çš„æ–‡ä»¶æ˜¯å¦æ˜¯å®é™…æ–‡ä»¶
                        all_path = os.path.join(
                            self.save_path, "å…¨éƒ¨", f"{new_name}.txt")
                        if os.path.isfile(all_path):
                            # å¦‚æœæ˜¯å®é™…æ–‡ä»¶ï¼Œåˆ™è®¤ä¸ºæ˜¯å†²çª
                            conflicts.append(category)
                    else:
                        # æ™®é€šåˆ†ç±»ç›´æ¥è®°å½•å†²çª
                        conflicts.append(category)
        return conflicts

    def save_current_role(self):
        """ä¿å­˜å½“å‰ç¼–è¾‘çš„è§’è‰²"""
        if not hasattr(self, 'current_role') or not self.current_role:
            return

        new_name = self.role_name_var.get().strip()
        if not new_name:
            self._show_message("warning", "è­¦å‘Š", "è§’è‰²åç§°ä¸èƒ½ä¸ºç©º")
            return

        # æ£€æŸ¥è§’è‰²åæ˜¯å¦é‡å¤
        if new_name != self.current_role:
            conflicts = self._check_role_name_conflict(new_name)
            if conflicts:
                messagebox.showerror("é”™è¯¯",       
                                    f"è§’è‰²åç§° '{new_name}' å·²å­˜åœ¨äºä»¥ä¸‹åˆ†ç±»ä¸­ï¼š\n" +
                                    "\n".join(conflicts) +
                                    "\nè¯·ä½¿ç”¨ä¸åŒçš„è§’è‰²åç§°", parent=self.window)
                return

        content = self._build_role_content()
        save_path = os.path.join(self.save_path, self.selected_category,
                                 f"{new_name}.txt")

        try:
            self._save_role_file(content, save_path)
            # å¦‚æœä¿®æ”¹äº†è§’è‰²åï¼Œæ›´æ–°æ–‡ä»¶å
            if new_name != self.current_role:
                old_path = os.path.join(self.save_path, self.selected_category,
                                        f"{self.current_role}.txt")
                os.rename(old_path, save_path)

            # æ›´æ–°æ˜¾ç¤º
            self.current_role = new_name
            self.show_category(self.selected_category)
            self.show_role(new_name)  # åˆ·æ–°è§’è‰²æ˜¾ç¤º
            messagebox.showinfo("æˆåŠŸ", "è§’è‰²å·²ä¿å­˜", parent=self.window)
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä¿å­˜å¤±è´¥ï¼š{str(e)}", parent=self.window)

    def _rename_role_file(self):
        """ä¿®æ”¹è§’è‰²åç§°"""
        old_name = self.current_role
        new_name = self.role_name_var.get().strip()

        if not old_name or not new_name:
            return

        # å¤„ç†ä¸­è‹±æ–‡å†’å·
        for colon in [":", "ï¼š"]:
            old_name = old_name.split(colon)[0]
            new_name = new_name.split(colon)[0]

        # å¦‚æœè§’è‰²åæ²¡æœ‰æ”¹å˜ï¼Œç›´æ¥è¿”å›
        if new_name == old_name:
            return

        # æ£€æŸ¥è§’è‰²åæ˜¯å¦é‡å¤
        conflicts = self._check_role_name_conflict(new_name)
        if conflicts:
            messagebox.showerror("é”™è¯¯",
                                f"è§’è‰²åç§° '{new_name}' å·²å­˜åœ¨äºä»¥ä¸‹åˆ†ç±»ä¸­ï¼š\n" +
                                "\n".join(conflicts) +
                                "\nè¯·ä½¿ç”¨ä¸åŒçš„è§’è‰²åç§°", parent=self.window)
            return

        try:
            # å¦‚æœæ˜¯"å…¨éƒ¨"åˆ†ç±»ï¼Œéœ€è¦æ‰¾åˆ°å®é™…å­˜å‚¨çš„åˆ†ç±»
            if self.selected_category == "å…¨éƒ¨":
                # é¦–å…ˆæ£€æŸ¥"å…¨éƒ¨"ç›®å½•ä¸‹æ˜¯å¦æœ‰è¯¥è§’è‰²æ–‡ä»¶
                all_path = os.path.join(
                    self.save_path, "å…¨éƒ¨", f"{old_name}.txt")
                if os.path.exists(all_path):
                    # å¦‚æœ"å…¨éƒ¨"ç›®å½•ä¸‹æœ‰æ–‡ä»¶ï¼Œåˆ™ç›´æ¥æ“ä½œ
                    actual_category = "å…¨éƒ¨"
                else:
                    # éå†æ‰€æœ‰åˆ†ç±»æŸ¥æ‰¾å®é™…å­˜å‚¨ä½ç½®
                    actual_category = None
                    for category in os.listdir(self.save_path):
                        if category == "å…¨éƒ¨":
                            continue
                        test_path = os.path.join(
                            self.save_path, category, f"{old_name}.txt")
                        if os.path.exists(test_path):
                            actual_category = category
                            break

                    if not actual_category:
                        raise FileNotFoundError(
                            f"æ‰¾ä¸åˆ°è§’è‰² {old_name} çš„å®é™…å­˜å‚¨ä½ç½®")
            else:
                actual_category = self.selected_category

            # è¯»å–æ—§æ–‡ä»¶å†…å®¹å¹¶æ›´æ–°è§’è‰²å
            old_path = os.path.join(
                self.save_path, actual_category, f"{old_name}.txt")
            with open(old_path, 'r', encoding='utf-8') as f:
                content = f.read()

            # è·å–ç¬¬ä¸€è¡Œå†…å®¹
            first_line = content.split('\n')[0].strip()
            # æå–å†…å®¹ä¸­çš„è§’è‰²å
            content_role_name = first_line.split('ï¼š')[0].split(':')[0].strip()
            # å¦‚æœå†…å®¹ä¸­çš„è§’è‰²åä¸æ—§æ–‡ä»¶åä¸åŒï¼Œæ›´æ–°å†…å®¹
            if content_role_name != old_name:
                content = content.replace(
                    f"{content_role_name}ï¼š", f"{new_name}ï¼š", 1)
            else:
                content = content.replace(f"{old_name}ï¼š", f"{new_name}ï¼š", 1)

            # å†™å…¥æ–°æ–‡ä»¶
            new_path = os.path.join(
                self.save_path, actual_category, f"{new_name}.txt")
            with open(new_path, 'w', encoding='utf-8') as f:
                f.write(content)

            # åˆ é™¤æ—§æ–‡ä»¶
            os.remove(old_path)

            # å¤„ç†"å…¨éƒ¨"ç›®å½•
            all_old_path = os.path.join(
                self.save_path, "å…¨éƒ¨", f"{old_name}.txt")
            all_new_path = os.path.join(
                self.save_path, "å…¨éƒ¨", f"{new_name}.txt")

            # å¦‚æœ"å…¨éƒ¨"ç›®å½•å­˜åœ¨æ—§æ–‡ä»¶
            if os.path.exists(all_old_path):
                try:
                    # æ›´æ–°"å…¨éƒ¨"ç›®å½•ä¸­çš„æ–‡ä»¶å†…å®¹
                    with open(all_old_path, 'r', encoding='utf-8') as f:
                        all_content = f.read()
                    updated_all_content = all_content.replace(
                        f"{old_name}ï¼š", f"{new_name}ï¼š", 1)

                    # å†™å…¥æ–°æ–‡ä»¶
                    with open(all_new_path, 'w', encoding='utf-8') as f:
                        f.write(updated_all_content)

                    # åˆ é™¤æ—§æ–‡ä»¶
                    os.remove(all_old_path)
                except Exception as e:
                    messagebox.showerror("é”™è¯¯", f"æ›´æ–°å…¨éƒ¨ç›®å½•å¤±è´¥: {str(e)}", parent=self.window)
                    # å›æ»šé‡å‘½åæ“ä½œ
                    os.rename(new_path, old_path)
                    return

            # åˆ·æ–°æ˜¾ç¤º
            self.current_role = new_name
            self.show_category(self.selected_category)
            self.role_name_var.set(new_name)
            self.show_role(new_name)  # åˆ·æ–°è§’è‰²æ˜¾ç¤ºåŒºåŸŸ

        except Exception as e:
            self._show_message("error", "é”™è¯¯", f"é‡å‘½åå¤±è´¥ï¼š{str(e)}")

    def _create_new_role(self, category):
        """åœ¨æŒ‡å®šåˆ†ç±»åˆ›å»ºæ–°è§’è‰²"""
        role_dir = os.path.join(self.save_path, category)
        base_name = "æœªå‘½å"
        counter = 1

        # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
        while os.path.exists(os.path.join(role_dir, f"{base_name}.txt")):
            base_name = f"æœªå‘½å{counter}"
            counter += 1

        # åˆ›å»ºåŸºç¡€æ–‡ä»¶ç»“æ„ï¼ˆåŒ…å«åˆå§‹æ¡ç›®ï¼‰
        content = f"{base_name}ï¼š\n" + "\n".join([
            "â”œâ”€â”€ç‰©å“ï¼š",
            "â”‚  â””â”€â”€å¾…è¡¥å……",
            "â”œâ”€â”€èƒ½åŠ›ï¼š",
            "â”‚  â””â”€â”€å¾…è¡¥å……",
            "â”œâ”€â”€çŠ¶æ€ï¼š",
            "â”‚  â””â”€â”€å¾…è¡¥å……",
            "â”œâ”€â”€ä¸»è¦è§’è‰²é—´å…³ç³»ç½‘ï¼š",
            "â”‚  â””â”€â”€å¾…è¡¥å……",
            "â”œâ”€â”€è§¦å‘æˆ–åŠ æ·±çš„äº‹ä»¶ï¼š",
            "â”‚  â””â”€â”€å¾…è¡¥å……"
        ])

        with open(os.path.join(role_dir, f"{base_name}.txt"), "w", encoding="utf-8") as f:
            f.write(content)

        # åˆ·æ–°æ˜¾ç¤º
        self.show_category(category)
        self.role_name_var.set(base_name)
        self.current_role = base_name

    def create_category_bar(self):
        """åˆ›å»ºåˆ†ç±»æŒ‰é’®åŒº"""
        category_frame = ctk.CTkFrame(self.window)
        category_frame.pack(fill="x", padx=10, pady=5)

        # æ“ä½œæç¤º
        ctk.CTkLabel(category_frame,
                     text="å³é”®åˆ†ç±»åå³å¯é‡å‘½å",
                     font=DEFAULT_FONT,
                     text_color="gray").pack(side="top", anchor="w", padx=5)

        # å›ºå®šæŒ‰é’®
        ctk.CTkButton(category_frame, text="å…¨éƒ¨", width=50,
                      font=("Microsoft YaHei", 12),
                      command=lambda: self.show_category("å…¨éƒ¨")).pack(side="left", padx=2)

        # æ»šåŠ¨åˆ†ç±»åŒº
        self.scroll_frame = ctk.CTkScrollableFrame(
            category_frame, orientation="horizontal", height=30)
        self.scroll_frame.pack(side="left", fill="x", expand=True, padx=5)

        # æ“ä½œæŒ‰é’®
        ctk.CTkButton(category_frame, text="æ–°å¢", width=50,
                      command=self.add_category, font=DEFAULT_FONT).pack(side="right", padx=2)
        ctk.CTkButton(category_frame, text="åˆ é™¤", width=50,
                      command=self.delete_category, font=DEFAULT_FONT).pack(side="right", padx=2)

        self.load_categories()

    def center_window(self):
        """çª—å£å±…ä¸­"""
        self.window.update_idletasks()
        parent_x = self.master.winfo_x()
        parent_y = self.master.winfo_y()
        parent_width = self.master.winfo_width()
        parent_height = self.master.winfo_height()
        win_width = 1200
        win_height = 800
        x = parent_x + (parent_width - win_width) // 2
        y = parent_y + (parent_height - win_height) // 2
        self.window.geometry(f"{win_width}x{win_height}+{x}+{y}")

    def load_categories(self):
        """åŠ è½½åˆ†ç±»æŒ‰é’®"""
        for widget in self.scroll_frame.winfo_children():
            widget.destroy()

        categories = [d for d in os.listdir(self.save_path)
                      if os.path.isdir(os.path.join(self.save_path, d)) and d != "å…¨éƒ¨"]

        for category in categories:
            btn = ctk.CTkButton(self.scroll_frame, text=category, width=80, font=DEFAULT_FONT)
            btn.bind("<Button-1>", lambda e, c=category: self.show_category(c))
            btn.bind("<Button-3>", lambda e, c=category: self.rename_category(c))
            btn.pack(side="left", padx=2)

    def _create_category_directory(self, category_name):
        """åˆ›å»ºåˆ†ç±»ç›®å½•"""
        new_dir = os.path.join(self.save_path, category_name)
        if not os.path.exists(new_dir):
            os.makedirs(new_dir)
        return new_dir

    def add_category(self):
        """æ–°å¢åˆ†ç±»"""
        self._create_category_directory("æœªå‘½å")
        self.load_categories()
        # åˆ·æ–°åˆ†ç±»é€‰æ‹©ä¸‹æ‹‰æ¡†
        self.category_combobox.configure(values=self._get_all_categories())

    def delete_category(self):
        """åˆ é™¤åˆ†ç±»å¯¹è¯æ¡†"""
        if not self.window.winfo_exists():
            return

        del_window = ctk.CTkToplevel(self.window)
        del_window.title("åˆ é™¤åˆ†ç±»")
        del_window.transient(self.window)
        del_window.grab_set()
        del_window.attributes('-topmost', 1)

        # å±…ä¸­è®¡ç®—
        parent_x = self.window.winfo_x()
        parent_y = self.window.winfo_y()
        parent_width = self.window.winfo_width()
        parent_height = self.window.winfo_height()
        del_window.geometry(
            f"300x400+{parent_x + (parent_width-300)//2}+{parent_y + (parent_height-400)//2}")

        scroll_frame = ctk.CTkScrollableFrame(del_window)
        scroll_frame.pack(fill="both", expand=True)

        categories = [d for d in os.listdir(self.save_path)
                      if os.path.isdir(os.path.join(self.save_path, d)) and d != "å…¨éƒ¨"]
        self.selected_del = []

        for cat in categories:
            var = tk.BooleanVar()
            chk = ctk.CTkCheckBox(scroll_frame, text=cat, variable=var, font=DEFAULT_FONT)
            chk.pack(anchor="w")
            self.selected_del.append((cat, var))

        # æ“ä½œæŒ‰é’®
        btn_frame = ctk.CTkFrame(del_window)
        btn_frame.pack(fill="x", pady=5)

        ctk.CTkButton(btn_frame, text="åˆ é™¤é€‰ä¸­",
                      command=lambda: self.confirm_delete(del_window), font=DEFAULT_FONT).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="å–æ¶ˆ",
                      command=del_window.destroy, font=DEFAULT_FONT).pack(side="right", padx=5)

        self.category_combobox.configure(values=self._get_all_categories())
        self.category_combobox.set("å…¨éƒ¨")

    def confirm_delete(self, original_window):
        """ç¡®è®¤åˆ é™¤æ“ä½œ"""
        selected = [item[0] for item in self.selected_del if item[1].get()]
        if not selected:
            self._show_message("warning", "è­¦å‘Š", "è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªåˆ†ç±»")
            return

        # åˆ›å»ºé€‰æ‹©çª—å£æ—¶æ·»åŠ å‰ç½®è®¾ç½®
        choice_window = ctk.CTkToplevel(self.window)
        choice_window.transient(self.window)  # è®¾ç½®ä¸ºå­çª—å£
        choice_window.grab_set()  # æ¨¡æ€çª—å£
        choice_window.lift()  # ç½®é¡¶
        choice_window.attributes('-topmost', 1)  # å¼ºåˆ¶ç½®é¡¶

        # æ·»åŠ å±…ä¸­è®¡ç®—
        choice_window.update_idletasks()
        c_width = choice_window.winfo_width()
        c_height = choice_window.winfo_height()
        x = self.window.winfo_x() + (self.window.winfo_width() - c_width) // 2
        y = self.window.winfo_y() + (self.window.winfo_height() - c_height) // 2
        choice_window.geometry(f"+{x}+{y}")

        ctk.CTkLabel(choice_window, text="è¯·é€‰æ‹©åˆ é™¤æ–¹å¼ï¼š", font=DEFAULT_FONT).pack(pady=10)
        btn_frame = ctk.CTkFrame(choice_window)
        btn_frame.pack(pady=10)

        def perform_delete(mode):
            all_dir = os.path.join(self.save_path, "å…¨éƒ¨")
            for cat in selected:
                cat_path = os.path.join(self.save_path, cat)
                if mode == "move":
                    for role_file in os.listdir(cat_path):
                        if role_file.endswith(".txt"):
                            src = os.path.join(cat_path, role_file)
                            dst = os.path.join(all_dir, role_file)
                            try:
                                shutil.move(src, dst)
                            except:
                                os.remove(dst)
                                shutil.move(src, dst)
                shutil.rmtree(cat_path)
            self.load_categories()
            # åˆ·æ–°åˆ†ç±»é€‰æ‹©ä¸‹æ‹‰æ¡†
            self.category_combobox.configure(values=self._get_all_categories())
            original_window.destroy()
            choice_window.destroy()

        ctk.CTkButton(btn_frame, text="å…¨éƒ¨åˆ é™¤",
                      command=lambda: perform_delete("all"), font=DEFAULT_FONT).pack(side="left", padx=5)
        ctk.CTkButton(btn_frame, text="ç§»åŠ¨è§’è‰²",
                      command=lambda: perform_delete("move"), font=DEFAULT_FONT).pack(side="left", padx=5)

    def count_roles(self, categories):
        """ç»Ÿè®¡è§’è‰²æ•°é‡"""
        count = 0
        for cat in categories:
            cat_path = os.path.join(self.save_path, cat)
            count += len([f for f in os.listdir(cat_path) if f.endswith(".txt")])
        return count

    def show_category(self, category):
        """æ˜¾ç¤ºåˆ†ç±»å†…å®¹"""
        self.selected_category = category
        self.category_combobox.set(category)
        for widget in self.role_list_frame.winfo_children():
            widget.destroy()

        # å¦‚æœæ˜¯"å…¨éƒ¨"åˆ†ç±»ï¼Œæ˜¾ç¤ºæ‰€æœ‰è§’è‰²
        if category == "å…¨éƒ¨":
            # è·å–æ‰€æœ‰åˆ†ç±»ç›®å½•
            categories = [d for d in os.listdir(self.save_path)
                          
                          if os.path.isdir(os.path.join(self.save_path, d))]
            # ç”¨äºå»é‡çš„è§’è‰²é›†åˆ
            unique_roles = set()

            for cat in categories:
                role_dir = os.path.join(self.save_path, cat)
                try:
                    for role_file in os.listdir(role_dir):
                        if role_file.endswith(".txt"):
                            role_name = os.path.splitext(role_file)[0]
                            # å»é‡
                            if role_name not in unique_roles:
                                unique_roles.add(role_name)
                                btn = ctk.CTkButton(
                                    self.role_list_frame,
                                    text=role_name,
                                    command=lambda r=role_name: self.show_role(r),
                                    font=DEFAULT_FONT
                                )
                                btn.pack(fill="x", pady=2)
                except FileNotFoundError:
                    continue
        else:
            # æ™®é€šåˆ†ç±»æ˜¾ç¤º
            role_dir = os.path.join(self.save_path, category)
            try:
                for role_file in os.listdir(role_dir):
                    if role_file.endswith(".txt"):
                        role_name = os.path.splitext(role_file)[0]
                        btn = ctk.CTkButton(
                            self.role_list_frame,
                            text=role_name,
                            command=lambda r=role_name: self.show_role(r),
                            font=DEFAULT_FONT
                        )
                        btn.pack(fill="x", pady=2)
            except FileNotFoundError:
                messagebox.showerror("é”™è¯¯", "åˆ†ç±»ç›®å½•ä¸å­˜åœ¨", parent=self.window)

    def show_role(self, role_name):
        """æ˜¾ç¤ºè§’è‰²è¯¦ç»†ä¿¡æ¯ï¼ˆæ”¯æŒUTF-8/ANSIç¼–ç ï¼‰"""
        try:
            # æ¸…ç©ºç°æœ‰å±æ€§æ§ä»¶
            self.preview_text.delete('1.0', tk.END)
            for widget in self.attributes_frame.winfo_children():
                widget.destroy()

            # æ›´æ–°è§’è‰²åç§°æ˜¾ç¤º
            self.current_role = role_name.split(":")[0].split("ï¼š")[0]
            self.role_name_var.set(self.current_role)

            # æŸ¥æ‰¾è§’è‰²å®é™…æ‰€åœ¨ç›®å½•
            if self.selected_category == "å…¨éƒ¨":
                # é¦–å…ˆæ£€æŸ¥"å…¨éƒ¨"ç›®å½•ä¸‹æ˜¯å¦æœ‰è¯¥è§’è‰²æ–‡ä»¶
                all_path = os.path.join(
                    self.save_path, "å…¨éƒ¨", f"{role_name}.txt")
                if os.path.exists(all_path):
                    file_path = all_path
                    actual_category = "å…¨éƒ¨"
                else:
                    # å¦‚æœ"å…¨éƒ¨"ç›®å½•ä¸‹æ²¡æœ‰ï¼Œåˆ™éå†å…¶ä»–åˆ†ç±»æŸ¥æ‰¾
                    file_path = None
                    for cat in os.listdir(self.save_path):
                        if cat == "å…¨éƒ¨":
                            continue
                        test_path = os.path.join(
                            self.save_path, cat, f"{role_name}.txt")
                        if os.path.exists(test_path):
                            file_path = test_path
                            actual_category = cat
                            # ä¿å­˜å®é™…åˆ†ç±»
                            self.actual_category = cat
                            break
                    if file_path is None:
                        raise FileNotFoundError(f"æ‰¾ä¸åˆ°è§’è‰²æ–‡ä»¶ï¼š{role_name}")

                # åªæ›´æ–°åˆ†ç±»é€‰æ‹©æ¡†çš„æ˜¾ç¤ºå€¼ï¼Œä¸æ”¹å˜å½“å‰é€‰ä¸­çš„åˆ†ç±»
                self.category_combobox.set(actual_category)
            else:
                # æ™®é€šåˆ†ç±»ç›´æ¥ä½¿ç”¨å½“å‰è·¯å¾„
                file_path = os.path.join(
                    self.save_path, self.selected_category, f"{role_name}.txt")

            content, _ = self._read_file_with_fallback_encoding(file_path)

            # è§£æå±æ€§ç»“æ„
            attributes = {
                "ç‰©å“": [],
                "èƒ½åŠ›": [],
                "çŠ¶æ€": [],
                "ä¸»è¦è§’è‰²é—´å…³ç³»ç½‘": [],
                "è§¦å‘æˆ–åŠ æ·±çš„äº‹ä»¶": []
            }
            current_attribute = None
            for line in content[1:]:
                # æ”¹è¿›å±æ€§åç§°è¯†åˆ«
                if line.startswith(("â”œâ”€â”€", "â”œâ”€â”€")):
                    # æå–å±æ€§åç§°ï¼ˆå…¼å®¹å†’å·å’Œç©ºæ ¼ï¼‰
                    attr_part = line.split("â”€â”€")[1].strip()
                    attr_name = re.split(r'[:ï¼š]', attr_part, 1)[0].strip()

                    # åŒ¹é…é¢„è®¾å±æ€§
                    for preset_attr in attributes:
                        if attr_name == preset_attr:
                            current_attribute = preset_attr
                            indent_level = line.find(
                                "â”œ") if "â”œ" in line else line.find("â”œ")
                            break
                    else:
                        current_attribute = None

                # æ”¹è¿›æ¡ç›®å†…å®¹æå–
                elif current_attribute and line.startswith(("â”‚  ", "   ")):
                    # æå–æ•´ä¸ªæ¡ç›®å†…å®¹
                    item_content = line.strip()
                    # å»æ‰å‰é¢çš„ç¬¦å·å’Œç©ºæ ¼
                    item_content = re.sub(r'^[â”‚â”œâ””â”€\s]*', '', item_content)
                    attributes[current_attribute].append(item_content)

            # æ˜¾ç¤ºåŸå§‹æ–‡ä»¶å†…å®¹
            self.preview_text.insert(tk.END, '\n'.join(content))

            # é‡æ„å±æ€§ç¼–è¾‘åŒº
            for attr_name, items in attributes.items():
                self._create_attribute_section(attr_name, items)

        except FileNotFoundError as e:
            messagebox.showerror("é”™è¯¯", f"æ–‡ä»¶ä¸å­˜åœ¨ï¼š{e}", parent=self.window)
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"è¯»å–æ–‡ä»¶å¤±è´¥ï¼š{e}", parent=self.window)

    def _create_attribute_section(self, attr_name, items):
        """åˆ›å»ºå•ä¸ªå±æ€§çš„ç¼–è¾‘åŒºåŸŸ"""

        # å±æ€§å— (attribute_block)
        attribute_block = ctk.CTkFrame(self.attributes_frame)
        attribute_block.pack(fill="x", pady=5)
        attribute_block.attribute_name = attr_name  # å­˜å‚¨å±æ€§åç§°
        attribute_block.grid_columnconfigure(1, weight=1)  # è®¾ç½®ç¬¬äºŒåˆ—æƒé‡
        attribute_block.grid_columnconfigure(1, weight=1)  # è®¾ç½®ç¬¬äºŒåˆ—æƒé‡

        # å±æ€§åç§°æ ‡ç­¾
        label = ctk.CTkLabel(attribute_block, text=attr_name, font=DEFAULT_FONT)
        label.grid(row=0, column=0, sticky="w", padx=(5, 10), pady=2)

        # ç¬¬ä¸€ä¸ªæ¡ç›®å’Œâ€œå¢åŠ â€æŒ‰é’®çš„å®¹å™¨
        first_item_frame = ctk.CTkFrame(attribute_block)
        first_item_frame.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        first_item_frame.grid_columnconfigure(0, weight=1)

        # ç¬¬ä¸€ä¸ªæ¡ç›®è¾“å…¥æ¡†
        first_entry = ctk.CTkEntry(first_item_frame, font=DEFAULT_FONT)
        first_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5), ipadx=5, ipady=3)
        if items:
            first_entry.insert(0, items[0])  # å¡«å……ç¬¬ä¸€ä¸ªæ¡ç›®çš„å†…å®¹

        # â€œå¢åŠ â€æŒ‰é’®å®¹å™¨
        add_button_frame = ctk.CTkFrame(first_item_frame, fg_color="transparent")
        add_button_frame.grid(row=0, column=1, sticky="e", padx=(5, 0))

        # â€œå¢åŠ â€æŒ‰é’®
        add_button = ctk.CTkButton(
            add_button_frame,
            text="+",
            width=30,
            command=lambda: self._add_item(attr_name),
            font=DEFAULT_FONT
        )
        add_button.grid(row=0, column=0)

        # åˆ›å»ºå‰©ä½™çš„æ¡ç›®ï¼ˆå¦‚æœæœ‰ï¼‰
        for i, item_text in enumerate(items[1:]):
            self._add_item(attr_name, item_text)  # ä¼ å…¥åˆå§‹æ–‡æœ¬

    def _add_item(self, attr_name, initial_text=""):
        """ä¸ºæŒ‡å®šå±æ€§æ·»åŠ ä¸€ä¸ªæ–°æ¡ç›®"""

        # æ‰¾åˆ°å¯¹åº”çš„ attribute_block
        attribute_block = None
        for block in self.attributes_frame.winfo_children():
            if isinstance(block, ctk.CTkFrame) and block.attribute_name == attr_name:
                attribute_block = block
                break

        if attribute_block is None:
            return

        # è®¡ç®—æ–°æ¡ç›®çš„è¡Œå·
        row_number = 0
        for child in attribute_block.winfo_children():
            if isinstance(child, ctk.CTkFrame):
                row_number += 1

        # æ¡ç›®å®¹å™¨
        item_frame = ctk.CTkFrame(attribute_block)
        item_frame.grid(row=row_number, column=1, sticky="ew", padx=5, pady=2)
        item_frame.grid_columnconfigure(0, weight=1)

        # æ¡ç›®è¾“å…¥æ¡†
        new_entry = ctk.CTkEntry(item_frame, font=DEFAULT_FONT)
        new_entry.grid(row=0, column=0, sticky="ew", padx=(0, 5), ipadx=5, ipady=3)
        new_entry.insert(0, initial_text)  # è®¾ç½®åˆå§‹æ–‡æœ¬

        # åˆ é™¤æŒ‰é’®å®¹å™¨
        del_button_frame = ctk.CTkFrame(item_frame, fg_color="transparent")
        del_button_frame.grid(row=0, column=1, sticky="e", padx=(5, 0))
        # â€œåˆ é™¤â€æŒ‰é’®
        del_button = ctk.CTkButton(
            del_button_frame,
            text="-",
            width=30,
            command=lambda f=item_frame: self._remove_item(f, attr_name),
            font=DEFAULT_FONT
        )
        del_button.grid(row=0, column=0)


    def _remove_item(self, item_frame, attr_name):
        """ç§»é™¤æŒ‡å®šçš„æ¡ç›®ï¼Œå¹¶é‡æ–°è°ƒæ•´å¸ƒå±€"""

        # æ‰¾åˆ°å¯¹åº”çš„ attribute_block
        attribute_block = None
        for block in self.attributes_frame.winfo_children():
            if isinstance(block, ctk.CTkFrame) and block.attribute_name == attr_name:
                attribute_block = block
                break

        if attribute_block is None:
            return

        # ç¡®è®¤ä¸æ˜¯åˆ é™¤å¸¦"+"å·çš„åŸå§‹æ¡ç›®
        for child in item_frame.winfo_children():
            if isinstance(child, ctk.CTkFrame):
                for btn in child.winfo_children():
                    if isinstance(btn, ctk.CTkButton) and btn.cget("text") == "+":
                        self._show_message("info", "æç¤º", "ä¸èƒ½åˆ é™¤å¸¦'+'å·çš„åŸå§‹æ¡ç›®")
                        return

        # ç§»é™¤æ¡ç›®
        item_frame.destroy()

        # é‡æ–°è°ƒæ•´å‰©ä½™æ¡ç›®çš„è¡Œå·
        current_row = 0
        for child in attribute_block.winfo_children():
            if isinstance(child, ctk.CTkFrame):
                if current_row == 0:  # æ‰¾åˆ°å±æ€§æ ‡ç­¾
                    current_row += 1
                    continue
                ctk.CTkFrame.grid_configure(child, row=current_row)
                current_row += 1

    def _read_file_with_fallback_encoding(self, file_path):
        """å¸¦ç¼–ç å›é€€çš„æ–‡ä»¶è¯»å–ï¼Œæ”¯æŒUTF-8ã€GBK(ANSI)å’ŒBOM"""
        encodings = ['utf-8-sig', 'utf-8', 'gbk', 'latin1']  # å¢åŠ æ›´å¤šç¼–ç æ”¯æŒ

        for encoding in encodings:
            try:
                with open(file_path, "r", encoding=encoding) as f:
                    content = f.read()
                    # æ£€æŸ¥å†…å®¹æ˜¯å¦åŒ…å«ä¹±ç 
                    if any(ord(char) > 127 and not char.isprintable() for char in content):
                        continue  # å¦‚æœåŒ…å«ä¹±ç ï¼Œå°è¯•ä¸‹ä¸€ä¸ªç¼–ç 
                    return content.splitlines(), encoding
            except UnicodeDecodeError:
                continue
            except Exception as e:
                raise

        # å¦‚æœæ‰€æœ‰ç¼–ç å°è¯•éƒ½å¤±è´¥ï¼Œå°è¯•äºŒè¿›åˆ¶è¯»å–
        try:
            with open(file_path, "rb") as f:
                raw_data = f.read()
                # å°è¯•UTF-8è§£ç 
                try:
                    return raw_data.decode('utf-8').splitlines(), 'utf-8'
                except UnicodeDecodeError:
                    # å°è¯•GBKè§£ç 
                    try:
                        return raw_data.decode('gbk').splitlines(), 'gbk'
                    except UnicodeDecodeError:
                        # æœ€åå°è¯•latin1è§£ç 
                        return raw_data.decode('latin1').splitlines(), 'latin1'
        except Exception as e:
            raise ValueError(f"æ— æ³•è¯†åˆ«çš„æ–‡ä»¶ç¼–ç ï¼š{file_path}")

    def rename_category(self, old_name):
        """åˆ†ç±»é‡å‘½åï¼ˆå¸¦å±…ä¸­åŠŸèƒ½ï¼‰"""
        new_name = None  # åˆå§‹åŒ–å˜é‡

        # åˆ›å»ºå¯¹è¯æ¡†çª—å£
        dialog = ctk.CTkToplevel(self.window)
        dialog.title("é‡å‘½ååˆ†ç±»")
        dialog.transient(self.window)
        dialog.grab_set()

        # çª—å£å†…å®¹
        content_frame = ctk.CTkFrame(dialog)
        content_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # é¡¶éƒ¨æç¤º
        ctk.CTkLabel(content_frame, text=f"å½“å‰åˆ†ç±»ï¼š{old_name}", 
                    font=DEFAULT_FONT).pack(pady=(10, 5))

        # è¾“å…¥æ¡†
        input_frame = ctk.CTkFrame(content_frame)
        input_frame.pack(fill="x", pady=5)
        ctk.CTkLabel(input_frame, text="æ–°åç§°ï¼š", 
                    font=DEFAULT_FONT).pack(side="left", padx=5)
        name_var = tk.StringVar()
        name_entry = ctk.CTkEntry(input_frame, textvariable=name_var, width=150, font=DEFAULT_FONT)
        name_entry.pack(side="left", padx=5)

        # æŒ‰é’®åŒº
        button_frame = ctk.CTkFrame(content_frame)
        button_frame.pack(fill="x", pady=(10, 5))

        def confirm_rename():
            nonlocal new_name  # å¼•ç”¨å¤–éƒ¨å˜é‡
            new_name = name_var.get().strip()
            if not new_name:
                messagebox.showwarning("è­¦å‘Š", "åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º", parent=self.window)
                return
            if new_name == old_name:
                dialog.destroy()
                return
            if os.path.exists(os.path.join(self.save_path, new_name)):
                messagebox.showerror("é”™è¯¯", "åˆ†ç±»åç§°å·²å­˜åœ¨", parent=self.window)
                return

            try:
                os.rename(os.path.join(self.save_path, old_name),
                          os.path.join(self.save_path, new_name))
                self.load_categories()
                # æ›´æ–°åˆ†ç±»é€‰æ‹©æ¡†
                self.category_combobox.configure(
                    values=self._get_all_categories())
                self.category_combobox.set(new_name)
                dialog.destroy()
            except Exception as e:
                messagebox.showerror("é”™è¯¯", f"é‡å‘½åå¤±è´¥ï¼š{str(e)}", parent=self.window)

        ctk.CTkButton(button_frame, text="ç¡®è®¤",
                      command=confirm_rename, font=DEFAULT_FONT).pack(side="left", padx=10)
        ctk.CTkButton(button_frame, text="å–æ¶ˆ",
                      command=dialog.destroy, font=DEFAULT_FONT).pack(side="right", padx=10)

        # çª—å£å±…ä¸­
        dialog.update_idletasks()
        d_width = dialog.winfo_width()
        d_height = dialog.winfo_height()
        x = self.window.winfo_x() + (self.window.winfo_width() - d_width) // 2
        y = self.window.winfo_y() + (self.window.winfo_height() - d_height) // 2
        dialog.geometry(f"+{x}+{y}")
        dialog.attributes('-topmost', 1)

    def on_close(self):
        """å…³é—­çª—å£"""
        self.window.destroy()
</file>

<file path="ui/main_window.py">
# ui/main_window.py
# -*- coding: utf-8 -*-
import os
import threading
import logging
import traceback
import customtkinter as ctk
import tkinter as tk
from tkinter import filedialog, messagebox
from .role_library import RoleLibrary
from llm_adapters import create_llm_adapter

from config_manager import load_config, save_config, test_llm_config, test_embedding_config
from utils import read_file, save_string_to_txt, clear_file_content
from tooltips import tooltips

from ui.context_menu import TextWidgetContextMenu
from ui.main_tab import build_main_tab, build_left_layout, build_right_layout
from ui.config_tab import build_config_tabview, load_config_btn, save_config_btn
from ui.novel_params_tab import build_novel_params_area, build_optional_buttons_area
from ui.generation_handlers import (
    generate_novel_architecture_ui,
    generate_chapter_blueprint_ui,
    generate_chapter_draft_ui,
    finalize_chapter_ui,
    do_consistency_check,
    import_knowledge_handler,
    clear_vectorstore_handler,
    show_plot_arcs_ui,
    generate_batch_ui,
    refine_directory_card_ui,
    show_foreshadowing_records_ui,
    show_novel_qa_ui as _show_novel_qa_ui
)
from ui.setting_tab import build_setting_tab, load_novel_architecture, save_novel_architecture
from ui.directory_tab import build_directory_tab, load_chapter_blueprint, save_chapter_blueprint
from ui.character_tab import build_character_tab, load_character_state, save_character_state
from ui.summary_tab import build_summary_tab, load_global_summary, save_global_summary
from ui.chapters_tab import build_chapters_tab, refresh_chapters_list, on_chapter_selected, load_chapter_content, save_current_chapter, prev_chapter, next_chapter
from ui.other_settings import build_other_settings_tab


class NovelGeneratorGUI:
    """
    å°è¯´ç”Ÿæˆå™¨çš„ä¸»GUIç±»ï¼ŒåŒ…å«æ‰€æœ‰çš„ç•Œé¢å¸ƒå±€ã€äº‹ä»¶å¤„ç†ã€ä¸åç«¯é€»è¾‘çš„äº¤äº’ç­‰ã€‚
    """
    def __init__(self, master):
        self.master = master
        # -- å£°æ˜å°†åœ¨ build_* å‡½æ•°ä¸­åˆå§‹åŒ–çš„å±æ€§ --
        self.log_text: ctk.CTkTextbox
        self.char_inv_text: ctk.CTkTextbox
        self.chapter_result: ctk.CTkTextbox
        self.tabview: ctk.CTkTabview
        self.master.title("Novel Generator GUI")
        try:
            if os.path.exists("icon.ico"):
                self.master.iconbitmap("icon.ico")
        except Exception:
            pass
        self.master.geometry("1350x840")

        # --------------- é…ç½®æ–‡ä»¶è·¯å¾„ ---------------
        self.config_file = "config.json"
        self.loaded_config = load_config(self.config_file)

        if self.loaded_config:
            last_llm = next(iter(self.loaded_config["llm_configs"].values())).get("interface_format", "OpenAI")

            last_embedding = self.loaded_config.get("last_embedding_interface_format", "OpenAI")
        else:
            last_llm = "OpenAI"
            last_embedding = "OpenAI"

        # if self.loaded_config and "llm_configs" in self.loaded_config and last_llm in self.loaded_config["llm_configs"]:
        #     llm_conf = next(iter(self.loaded_config["llm_configs"]))
        # else:
        #     llm_conf = {
        #         "api_key": "",
        #         "base_url": "https://api.openai.com/v1",
        #         "model_name": "gpt-4o-mini",
        #         "temperature": 0.7,
        #         "max_tokens": 8192,
        #         "timeout": 600
        #     }
        llm_conf = next(iter(self.loaded_config["llm_configs"].values()))
        choose_configs = self.loaded_config.get("choose_configs", {})


        if self.loaded_config and "embedding_configs" in self.loaded_config and last_embedding in self.loaded_config["embedding_configs"]:
            emb_conf = self.loaded_config["embedding_configs"][last_embedding]
        else:
            emb_conf = {
                "api_key": "",
                "base_url": "https://api.openai.com/v1",
                "model_name": "text-embedding-ada-002",
                "retrieval_k": 4
            }

        # PenBo å¢åŠ ä»£ç†åŠŸèƒ½æ”¯æŒ
        proxy_url = self.loaded_config["proxy_setting"]["proxy_url"]
        proxy_port = self.loaded_config["proxy_setting"]["proxy_port"]
        if self.loaded_config["proxy_setting"]["enabled"]:
            os.environ['HTTP_PROXY'] = f"http://{proxy_url}:{proxy_port}"
            os.environ['HTTPS_PROXY'] = f"http://{proxy_url}:{proxy_port}"
        else:
            os.environ.pop('HTTP_PROXY', None)  
            os.environ.pop('HTTPS_PROXY', None)



        # -- LLMé€šç”¨å‚æ•° --
        # self.llm_conf_name = next(iter(self.loaded_config["llm_configs"]))
        self.api_key_var = ctk.StringVar(value=llm_conf.get("api_key", ""))
        self.base_url_var = ctk.StringVar(value=llm_conf.get("base_url", "https://api.openai.com/v1"))
        self.interface_format_var = ctk.StringVar(value=llm_conf.get("interface_format", "OpenAI"))
        self.model_name_var = ctk.StringVar(value=llm_conf.get("model_name", "gpt-4o-mini"))
        self.temperature_var = ctk.DoubleVar(value=llm_conf.get("temperature", 0.7))
        self.max_tokens_var = ctk.IntVar(value=llm_conf.get("max_tokens", 8192))
        self.timeout_var = ctk.IntVar(value=llm_conf.get("timeout", 600))
        self.interface_config_var = ctk.StringVar(value=next(iter(self.loaded_config["llm_configs"])))



        # -- Embeddingç›¸å…³ --
        self.embedding_interface_format_var = ctk.StringVar(value=last_embedding)
        self.embedding_api_key_var = ctk.StringVar(value=emb_conf.get("api_key", ""))
        self.embedding_url_var = ctk.StringVar(value=emb_conf.get("base_url", "https://api.openai.com/v1"))
        self.embedding_model_name_var = ctk.StringVar(value=emb_conf.get("model_name", "text-embedding-ada-002"))
        self.embedding_retrieval_k_var = ctk.StringVar(value=str(emb_conf.get("retrieval_k", 4)))


        # -- ç”Ÿæˆé…ç½®ç›¸å…³ --
        self.architecture_llm_var = ctk.StringVar(value=choose_configs.get("architecture_llm", "DeepSeek"))
        self.chapter_outline_llm_var = ctk.StringVar(value=choose_configs.get("chapter_outline_llm", "DeepSeek"))
        self.final_chapter_llm_var = ctk.StringVar(value=choose_configs.get("final_chapter_llm", "DeepSeek"))
        self.consistency_review_llm_var = ctk.StringVar(value=choose_configs.get("consistency_review_llm", "DeepSeek"))
        self.prompt_draft_llm_var = ctk.StringVar(value=choose_configs.get("prompt_draft_llm", "DeepSeek"))
        self.refine_logic_llm_var = ctk.StringVar(value=choose_configs.get("refine_logic_llm", "DeepSeek"))
        self.logic_rewrite_llm_var = ctk.StringVar(value=choose_configs.get("logic_rewrite_llm", "DeepSeek"))




        # -- å°è¯´å‚æ•°ç›¸å…³ --
        if self.loaded_config and "other_params" in self.loaded_config:
            op = self.loaded_config["other_params"]
            self.topic_default = op.get("topic", "")
            self.genre_var = ctk.StringVar(value=op.get("genre", "ç„å¹»"))
            self.num_chapters_var = ctk.StringVar(value=str(op.get("num_chapters", 10)))
            self.word_number_var = ctk.StringVar(value=str(op.get("word_number", 3000)))
            self.filepath_var = ctk.StringVar(value=op.get("filepath", ""))
            self.chapter_num_var = ctk.StringVar(value=str(op.get("chapter_num", "1")))
            self.characters_involved_var = ctk.StringVar(value=op.get("characters_involved", ""))
            self.key_items_var = ctk.StringVar(value=op.get("key_items", ""))
            self.scene_location_var = ctk.StringVar(value=op.get("scene_location", ""))
            self.time_constraint_var = ctk.StringVar(value=op.get("time_constraint", ""))
            self.user_guidance_default = op.get("user_guidance", "")
            self.webdav_url_var = ctk.StringVar(value=op.get("webdav_url", ""))
            self.webdav_username_var = ctk.StringVar(value=op.get("webdav_username", ""))
            self.webdav_password_var = ctk.StringVar(value=op.get("webdav_password", ""))

        else:
            self.topic_default = ""
            self.genre_var = ctk.StringVar(value="ç„å¹»")
            self.num_chapters_var = ctk.StringVar(value="10")
            self.word_number_var = ctk.StringVar(value="3000")
            self.filepath_var = ctk.StringVar(value="")
            self.chapter_num_var = ctk.StringVar(value="1")
            self.characters_involved_var = ctk.StringVar(value="")
            self.key_items_var = ctk.StringVar(value="")
            self.scene_location_var = ctk.StringVar(value="")
            self.time_constraint_var = ctk.StringVar(value="")
            self.user_guidance_default = ""

            self.webdav_url_var = ctk.StringVar(value="")
            self.webdav_username_var = ctk.StringVar(value="")
            self.webdav_password_var = ctk.StringVar(value="")

        # --------------- æ•´ä½“Tabå¸ƒå±€ ---------------
        self.tabview = ctk.CTkTabview(self.master)
        self.tabview.pack(fill="both", expand=True)

        # åˆ›å»ºå„ä¸ªæ ‡ç­¾é¡µ
        build_main_tab(self)
        build_config_tabview(self)
        build_novel_params_area(self, start_row=1)
        build_optional_buttons_area(self, start_row=2)
        build_setting_tab(self)
        build_directory_tab(self)
        build_character_tab(self)
        build_summary_tab(self)
        build_chapters_tab(self)
        build_other_settings_tab(self)

        self.show_novel_qa_ui = lambda: _show_novel_qa_ui(self)


    # ----------------- é€šç”¨è¾…åŠ©å‡½æ•° -----------------
    def show_tooltip(self, key: str):
        info_text = tooltips.get(key, "æš‚æ— è¯´æ˜")
        messagebox.showinfo("å‚æ•°è¯´æ˜", info_text)

    def safe_get_int(self, var, default=1):
        try:
            val_str = str(var.get()).strip()
            return int(val_str)
        except:
            var.set(str(default))
            return default

    def log(self, message: str):
        self.log_text.configure(state="normal")
        self.log_text.insert("end", message + "\n")
        self.log_text.see("end")
        self.log_text.configure(state="disabled")

    def safe_log(self, message: str):
        self.master.after(0, lambda: self.log(message))

    def disable_button_safe(self, btn):
        self.master.after(0, lambda: btn.configure(state="disabled"))

    def enable_button_safe(self, btn):
        self.master.after(0, lambda: btn.configure(state="normal"))

    def handle_exception(self, context: str):
        full_message = f"{context}\n{traceback.format_exc()}"
        logging.error(full_message)
        self.safe_log(full_message)

    def show_chapter_in_textbox(self, text: str):
        self.chapter_result.delete("0.0", "end")
        self.chapter_result.insert("0.0", text)
        self.chapter_result.see("end")
    
    def test_llm_config(self):
        """
        æµ‹è¯•å½“å‰çš„LLMé…ç½®æ˜¯å¦å¯ç”¨
        """
        interface_format = self.interface_format_var.get().strip()
        api_key = self.api_key_var.get().strip()
        base_url = self.base_url_var.get().strip()
        model_name = self.model_name_var.get().strip()
        temperature = self.temperature_var.get()
        max_tokens = self.max_tokens_var.get()
        timeout = self.timeout_var.get()

        test_llm_config(
            interface_format=interface_format,
            api_key=api_key,
            base_url=base_url,
            model_name=model_name,
            temperature=temperature,
            max_tokens=max_tokens,
            timeout=timeout,
            log_func=self.safe_log,
            handle_exception_func=self.handle_exception
        )

    def test_embedding_config(self):
        """
        æµ‹è¯•å½“å‰çš„Embeddingé…ç½®æ˜¯å¦å¯ç”¨
        """
        api_key = self.embedding_api_key_var.get().strip()
        base_url = self.embedding_url_var.get().strip()
        interface_format = self.embedding_interface_format_var.get().strip()
        model_name = self.embedding_model_name_var.get().strip()

        test_embedding_config(
            api_key=api_key,
            base_url=base_url,
            interface_format=interface_format,
            model_name=model_name,
            log_func=self.safe_log,
            handle_exception_func=self.handle_exception
        )
    
    def browse_folder(self):
        selected_dir = filedialog.askdirectory()
        if selected_dir:
            self.filepath_var.set(selected_dir)

    def show_character_import_window(self):
        """æ˜¾ç¤ºè§’è‰²å¯¼å…¥çª—å£"""
        import_window = ctk.CTkToplevel(self.master)
        import_window.title("å¯¼å…¥è§’è‰²ä¿¡æ¯")
        import_window.geometry("600x500")
        import_window.transient(self.master)  # è®¾ç½®ä¸ºçˆ¶çª—å£çš„ä¸´æ—¶çª—å£
        import_window.grab_set()  # ä¿æŒçª—å£åœ¨é¡¶å±‚
        
        # ä¸»å®¹å™¨
        main_frame = ctk.CTkFrame(import_window)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # æ»šåŠ¨å®¹å™¨
        scroll_frame = ctk.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill="both", expand=True, padx=5, pady=5)
        
        # è·å–è§’è‰²åº“è·¯å¾„
        role_lib_path = os.path.join(self.filepath_var.get().strip(), "è§’è‰²åº“")
        self.selected_roles = []  # å­˜å‚¨é€‰ä¸­çš„è§’è‰²åç§°
        
        # åŠ¨æ€åŠ è½½è§’è‰²åˆ†ç±»
        if os.path.exists(role_lib_path):
            # é…ç½®ç½‘æ ¼å¸ƒå±€å‚æ•°
            scroll_frame.columnconfigure(0, weight=1)
            max_roles_per_row = 4
            current_row = 0
            
            for category in os.listdir(role_lib_path):
                category_path = os.path.join(role_lib_path, category)
                if os.path.isdir(category_path):
                    # åˆ›å»ºåˆ†ç±»å®¹å™¨
                    category_frame = ctk.CTkFrame(scroll_frame)
                    category_frame.grid(row=current_row, column=0, sticky="w", pady=(10,5), padx=5)
                    
                    # æ·»åŠ åˆ†ç±»æ ‡ç­¾
                    category_label = ctk.CTkLabel(category_frame, text=f"ã€{category}ã€‘", 
                                                font=("Microsoft YaHei", 12, "bold"))
                    category_label.grid(row=0, column=0, padx=(0,10), sticky="w")
                    
                    # åˆå§‹åŒ–è§’è‰²æ’åˆ—å‚æ•°
                    role_count = 0
                    row_num = 0
                    col_num = 1  # ä»ç¬¬1åˆ—å¼€å§‹ï¼ˆç¬¬0åˆ—æ˜¯åˆ†ç±»æ ‡ç­¾ï¼‰
                    
                    # æ·»åŠ è§’è‰²å¤é€‰æ¡†
                    for role_file in os.listdir(category_path):
                        if role_file.endswith(".txt"):
                            role_name = os.path.splitext(role_file)[0]
                            if not any(name == role_name for _, name in self.selected_roles):
                                chk = ctk.CTkCheckBox(category_frame, text=role_name)
                                chk.grid(row=row_num, column=col_num, padx=5, pady=2, sticky="w")
                                self.selected_roles.append((chk, role_name))
                                
                                # æ›´æ–°è¡Œåˆ—ä½ç½®
                                role_count += 1
                                col_num += 1
                                if col_num > max_roles_per_row:
                                    col_num = 1
                                    row_num += 1
                    
                    # å¦‚æœæ²¡æœ‰è§’è‰²ï¼Œè°ƒæ•´åˆ†ç±»æ ‡ç­¾å æ»¡æ•´è¡Œ
                    if role_count == 0:
                        category_label.grid(columnspan=max_roles_per_row+1, sticky="w")
                    
                    # æ›´æ–°ä¸»å¸ƒå±€çš„è¡Œå·
                    current_row += 1
                    
                    # æ·»åŠ åˆ†éš”çº¿
                    separator = ctk.CTkFrame(scroll_frame, height=1, fg_color="gray")
                    separator.grid(row=current_row, column=0, sticky="ew", pady=5)
                    current_row += 1
        
        # åº•éƒ¨æŒ‰é’®æ¡†æ¶
        btn_frame = ctk.CTkFrame(main_frame)
        btn_frame.pack(fill="x", pady=10)
        
        # é€‰æ‹©æŒ‰é’®
        def confirm_selection():
            selected = [name for chk, name in self.selected_roles if chk.get() == 1]
            self.char_inv_text.delete("0.0", "end")
            self.char_inv_text.insert("0.0", ", ".join(selected))
            import_window.destroy()
            
        btn_confirm = ctk.CTkButton(btn_frame, text="é€‰æ‹©", command=confirm_selection)
        btn_confirm.pack(side="left", padx=20)
        
        # å–æ¶ˆæŒ‰é’®
        btn_cancel = ctk.CTkButton(btn_frame, text="å–æ¶ˆ", command=import_window.destroy)
        btn_cancel.pack(side="right", padx=20)

    def show_role_library(self):
        save_path = self.filepath_var.get().strip()
        if not save_path:
            messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆè®¾ç½®ä¿å­˜è·¯å¾„")
            return
        
        # [ä¿®æ”¹] åˆå§‹åŒ–LLMé€‚é…å™¨ï¼šä½¿ç”¨ "refine_logic_llm_var"
        try:
            logic_llm_key = self.refine_logic_llm_var.get()
            logic_config = self.loaded_config["llm_configs"][logic_llm_key]
            
            llm_adapter = create_llm_adapter(
                interface_format=logic_config.get("interface_format", "OpenAI"),
                base_url=logic_config.get("base_url", ""),
                model_name=logic_config.get("model_name", ""),
                api_key=logic_config.get("api_key", ""),
                temperature=float(logic_config.get("temperature", 0.7)),
                max_tokens=int(logic_config.get("max_tokens", 4096)),
                timeout=int(logic_config.get("timeout", 600))
            )
        except Exception as e:
            messagebox.showerror("é…ç½®é”™è¯¯", f"æ— æ³•åŠ è½½é€»è¾‘/é€‰è§’æ¨¡å‹é…ç½®: {str(e)}")
            return
        
        # ä¼ é€’LLMé€‚é…å™¨å®ä¾‹åˆ°è§’è‰²åº“
        if hasattr(self, '_role_lib'):
            if self._role_lib.window and self._role_lib.window.winfo_exists():
                self._role_lib.window.destroy()
        
        self._role_lib = RoleLibrary(self.master, save_path, llm_adapter)

    # ----------------- å°†å¯¼å…¥çš„å„æ¨¡å—å‡½æ•°ç›´æ¥èµ‹ç»™ç±»æ–¹æ³• -----------------
    generate_novel_architecture_ui = generate_novel_architecture_ui
    generate_chapter_blueprint_ui = generate_chapter_blueprint_ui
    generate_chapter_draft_ui = generate_chapter_draft_ui
    finalize_chapter_ui = finalize_chapter_ui
    do_consistency_check = do_consistency_check
    generate_batch_ui = generate_batch_ui
    refine_directory_card_ui = refine_directory_card_ui
    import_knowledge_handler = import_knowledge_handler
    clear_vectorstore_handler = clear_vectorstore_handler
    show_plot_arcs_ui = show_plot_arcs_ui
    show_foreshadowing_records_ui = show_foreshadowing_records_ui
    show_novel_qa_ui = _show_novel_qa_ui
    load_config_btn = load_config_btn
    save_config_btn = save_config_btn
    load_novel_architecture = load_novel_architecture
    save_novel_architecture = save_novel_architecture
    load_chapter_blueprint = load_chapter_blueprint
    save_chapter_blueprint = save_chapter_blueprint
    load_character_state = load_character_state
    save_character_state = save_character_state
    load_global_summary = load_global_summary
    save_global_summary = save_global_summary
    refresh_chapters_list = refresh_chapters_list
    on_chapter_selected = on_chapter_selected
    save_current_chapter = save_current_chapter
    prev_chapter = prev_chapter
    next_chapter = next_chapter
    test_llm_config = test_llm_config
    test_embedding_config = test_embedding_config
    browse_folder = browse_folder
</file>

<file path="ui/config_tab.py">
# ui/config_tab.py
# -*- coding: utf-8 -*-
from tkinter import messagebox
import uuid
import datetime

import customtkinter as ctk

from config_manager import load_config, save_config
from tooltips import tooltips

import os


def create_label_with_help(self, parent, label_text, tooltip_key, row, column,
                           font=None, sticky="e", padx=5, pady=5):
    """
    å°è£…ä¸€ä¸ªå¸¦"?"æŒ‰é’®çš„Labelï¼Œç”¨äºå±•ç¤ºæç¤ºä¿¡æ¯ã€‚
    """
    frame = ctk.CTkFrame(parent)
    frame.grid(row=row, column=column, padx=padx, pady=pady, sticky=sticky)
    frame.columnconfigure(0, weight=0)

    label = ctk.CTkLabel(frame, text=label_text, font=font)
    label.pack(side="left")

    btn = ctk.CTkButton(
        frame,
        text="?",
        width=22,
        height=22,
        font=("Microsoft YaHei", 10),
        command=lambda: messagebox.showinfo("å‚æ•°è¯´æ˜", tooltips.get(tooltip_key, "æš‚æ— è¯´æ˜"))
    )
    btn.pack(side="left", padx=3)

    return frame

def build_config_tabview(self):
    """
    åˆ›å»ºåŒ…å« LLM Model settings å’Œ Embedding settings çš„é€‰é¡¹å¡ã€‚
    """
    self.config_tabview = ctk.CTkTabview(self.config_frame)
    self.config_tabview.grid(row=0, column=0, sticky="we", padx=5, pady=5)

    self.ai_config_tab = self.config_tabview.add("LLM Model settings")
    self.embeddings_config_tab = self.config_tabview.add("Embedding settings")
    self.config_choose = self.config_tabview.add("Config choose")

    # PenBo å¢åŠ ä»£ç†åŠŸèƒ½æ”¯æŒ
    self.proxy_setting_tab = self.config_tabview.add("Proxy setting")


    build_ai_config_tab(self)
    build_embeddings_config_tab(self)
    build_config_choose_tab(self)

    # PenBo å¢åŠ ä»£ç†åŠŸèƒ½æ”¯æŒ
    build_proxy_setting_tab(self)

def build_ai_config_tab(self):
    def refresh_config_dropdown():
        """åˆ·æ–°é…ç½®ä¸‹æ‹‰èœå•"""
        config_names = list(self.loaded_config.get("llm_configs", {}).keys())
        interface_config_dropdown.configure(values=config_names)
        if config_names and self.interface_config_var.get() not in config_names:
            self.interface_config_var.set(config_names[0])

    def on_config_selected(new_value):
        """å½“é€‰æ‹©ä¸åŒé…ç½®æ—¶çš„å›è°ƒ"""
        if new_value in self.loaded_config.get("llm_configs", {}):
            config = self.loaded_config["llm_configs"][new_value]
            # æ›´æ–°æ‰€æœ‰UIå˜é‡
            self.api_key_var.set(config.get("api_key", ""))
            self.base_url_var.set(config.get("base_url", ""))
            self.model_name_var.set(config.get("model_name", ""))
            self.temperature_var.set(float(config.get("temperature", 0.7)))
            self.max_tokens_var.set(int(config.get("max_tokens", 8192)))
            self.timeout_var.set(int(config.get("timeout", 600)))
            self.interface_format_var.set(config.get("interface_format", "OpenAI"))
            
            # æ›´æ–°æ˜¾ç¤ºæ ‡ç­¾
            self.temp_value_label.configure(text=f"{float(config.get('temperature', 0.7)):.2f}")
            self.max_tokens_value_label.configure(text=str(int(config.get('max_tokens', 8192))))
            self.timeout_value_label.configure(text=str(int(config.get('timeout', 600))))

    def add_new_config():
        """æ·»åŠ æ–°é…ç½® - å¼¹å‡ºå¯¹è¯æ¡†è®©ç”¨æˆ·è¾“å…¥åç§°"""
        dialog = ctk.CTkInputDialog(
            text="è¯·è¾“å…¥æ–°é…ç½®åç§°:",
            title="æ–°å¢é…ç½®"
        )
        new_name = dialog.get_input()
        
        if not new_name:
            return
            
        new_name = new_name.strip()
        
        if new_name in self.loaded_config.get("llm_configs", {}):
            messagebox.showerror("é”™è¯¯", f"é…ç½®åç§° '{new_name}' å·²å­˜åœ¨!")
            return
            
        if "llm_configs" not in self.loaded_config:
            self.loaded_config["llm_configs"] = {}
            
        self.loaded_config["llm_configs"][new_name] = {
            "id": str(uuid.uuid4()),
            "api_key": "",
            "base_url": "",
            "model_name": "",
            "temperature": 0.7,
            "max_tokens": 8192,
            "timeout": 600,
            "interface_format": "OpenAI",
            "created_at": datetime.datetime.now().isoformat()
        }
        
        refresh_config_dropdown()
        self.interface_config_var.set(new_name)
        messagebox.showinfo("æç¤º", f"å·²æˆåŠŸåˆ›å»ºæ–°é…ç½®: {new_name}")

    def delete_current_config():
        """åˆ é™¤å½“å‰é€‰ä¸­çš„é…ç½®å¹¶ä¿å­˜åˆ°JSONæ–‡ä»¶"""
        selected_config = self.interface_config_var.get()
        
        if selected_config not in self.loaded_config.get("llm_configs", {}):
            messagebox.showerror("é”™è¯¯", "æœªæ‰¾åˆ°é€‰ä¸­çš„é…ç½®!")
            return
        
        if len(self.loaded_config["llm_configs"]) <= 1:
            messagebox.showerror("é”™è¯¯", "è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªé…ç½®!")
            return
        
        confirm = messagebox.askyesno(
            "ç¡®è®¤åˆ é™¤",
            f"ç¡®å®šè¦åˆ é™¤é…ç½® '{selected_config}' å—?\næ­¤æ“ä½œä¸å¯æ’¤é”€!"
        )
        
        if not confirm:
            return
        
        try:
            del self.loaded_config["llm_configs"][selected_config]
            refresh_config_dropdown()
            save_config(self.loaded_config, self.config_file)
            messagebox.showinfo("æç¤º", f"å·²åˆ é™¤é…ç½®: {selected_config}ï¼Œå¹¶å·²æ›´æ–°é…ç½®æ–‡ä»¶")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {str(e)}")

    def save_current_config():
        """ä¿å­˜å½“å‰é…ç½®çš„ä¿®æ”¹åˆ°JSONæ–‡ä»¶"""
        config_name = self.interface_config_var.get()
        if config_name not in self.loaded_config.get("llm_configs", {}):
            messagebox.showerror("é”™è¯¯", "é…ç½®ä¸å­˜åœ¨!")
            return
            
        config = self.loaded_config["llm_configs"][config_name]
        config.update({
            "api_key": self.api_key_var.get(),
            "base_url": self.base_url_var.get(),
            "model_name": self.model_name_var.get(),
            "temperature": float(self.temperature_var.get()),
            "max_tokens": int(self.max_tokens_var.get()),
            "timeout": int(self.timeout_var.get()),
            "interface_format": self.interface_format_var.get(),
            "updated_at": datetime.datetime.now().isoformat()
        })
        
        # å¦‚æœä¿®æ”¹äº†é…ç½®åç§°
        new_name = self.interface_config_var.get()
        if new_name != config_name:
            self.loaded_config["llm_configs"][new_name] = self.loaded_config["llm_configs"].pop(config_name)
            refresh_config_dropdown()
        embedding_config = {
        "api_key": self.embedding_api_key_var.get(),
        "base_url": self.embedding_url_var.get(),
        "model_name": self.embedding_model_name_var.get(),
        "retrieval_k": self.safe_get_int(self.embedding_retrieval_k_var, 4),
        "interface_format": self.embedding_interface_format_var.get().strip()

        }
        other_params = {
            "topic": self.topic_text.get("0.0", "end").strip(),
            "genre": self.genre_var.get(),
            "num_chapters": self.safe_get_int(self.num_chapters_var, 10),
            "word_number": self.safe_get_int(self.word_number_var, 3000),
            "filepath": self.filepath_var.get(),
            "chapter_num": self.chapter_num_var.get(),
            "user_guidance": self.user_guide_text.get("0.0", "end").strip(),
            "characters_involved": self.characters_involved_var.get(),
            "key_items": self.key_items_var.get(),
            "scene_location": self.scene_location_var.get(),
            "time_constraint": self.time_constraint_var.get()
        }
        self.loaded_config["embedding_configs"][self.embedding_interface_format_var.get().strip()] = embedding_config
        self.loaded_config["other_params"] = other_params


        # ä¿å­˜åˆ°JSONæ–‡ä»¶
        try:
            save_config(self.loaded_config, self.config_file)
            messagebox.showinfo("æç¤º", f"é…ç½® {new_name} å·²ä¿å­˜å¹¶æŒä¹…åŒ–åˆ°æ–‡ä»¶")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"ä¿å­˜é…ç½®æ–‡ä»¶å¤±è´¥: {str(e)}")

    def rename_current_config():
        """é‡å‘½åå½“å‰é…ç½®"""
        old_name = self.interface_config_var.get()
        if old_name not in self.loaded_config.get("llm_configs", {}):
            messagebox.showerror("é”™è¯¯", "å½“å‰é…ç½®ä¸å­˜åœ¨!")
            return
            
        dialog = ctk.CTkInputDialog(
            text=f"è¯·è¾“å…¥æ–°çš„é…ç½®åç§° (åŸåç§°: {old_name}):",
            title="é‡å‘½åé…ç½®"
        )
        new_name = dialog.get_input()
        
        if not new_name:
            return
            
        new_name = new_name.strip()
        
        if new_name == old_name:
            return
            
        if new_name in self.loaded_config.get("llm_configs", {}):
            messagebox.showerror("é”™è¯¯", f"é…ç½®åç§° '{new_name}' å·²å­˜åœ¨!")
            return
            
        # æ›´æ–°é…ç½®åç§°
        self.loaded_config["llm_configs"][new_name] = self.loaded_config["llm_configs"].pop(old_name)
        self.interface_config_var.set(new_name)
        refresh_config_dropdown()

        messagebox.showinfo("æç¤º", f"é…ç½®å·²ä» '{old_name}' é‡å‘½åä¸º '{new_name}'")

    # åˆå§‹åŒ–UIå¸ƒå±€
    for i in range(10):
        self.ai_config_tab.grid_rowconfigure(i, weight=0)
    self.ai_config_tab.grid_columnconfigure(0, weight=0)
    self.ai_config_tab.grid_columnconfigure(1, weight=1)
    self.ai_config_tab.grid_columnconfigure(2, weight=0)

    # é…ç½®é€‰æ‹©æ§ä»¶
    create_label_with_help(self, self.ai_config_tab, "å½“å‰é…ç½®", "interface_config", 0, 0)
    config_names = list(self.loaded_config.get("llm_configs", {}).keys())
    if not config_names:
        self.loaded_config["llm_configs"] = {
            "é»˜è®¤é…ç½®": {
                "id": str(uuid.uuid4()),
                "api_key": "",
                "base_url": "https://api.openai.com/v1",
                "model_name": "gpt-4",
                "temperature": 0.7,
                "max_tokens": 8192,
                "timeout": 600,
                "interface_format": "OpenAI",
                "created_at": datetime.datetime.now().isoformat()
            }
        }
        config_names = ["é»˜è®¤é…ç½®"]
    
    self.interface_config_var = ctk.StringVar(value=config_names[0])

    interface_config_dropdown = ctk.CTkOptionMenu(
        self.ai_config_tab, 
        values=config_names,
        variable=self.interface_config_var,
        command=on_config_selected,
        font=("Microsoft YaHei", 12)
    )
    interface_config_dropdown.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")

    # é…ç½®ç®¡ç†æŒ‰é’®ç»„
    btn_frame = ctk.CTkFrame(self.ai_config_tab)
    btn_frame.grid(row=1, column=0, columnspan=3, padx=5, pady=5, sticky="ew")
    btn_frame.columnconfigure(0, weight=1)
    btn_frame.columnconfigure(1, weight=1)
    btn_frame.columnconfigure(2, weight=1)
    btn_frame.columnconfigure(3, weight=1)

    add_btn = ctk.CTkButton(
        btn_frame, 
        text="â• æ–°å¢", 
        command=add_new_config,
        font=("Microsoft YaHei", 12),
        fg_color="#2E8B57",
        width=80
    )
    add_btn.grid(row=0, column=0, padx=2, pady=2, sticky="ew")

    rename_btn = ctk.CTkButton(
        btn_frame, 
        text="âœï¸ é‡å‘½å", 
        command=rename_current_config,
        font=("Microsoft YaHei", 12),
        fg_color="#DAA520",
        width=80
    )
    rename_btn.grid(row=0, column=1, padx=2, pady=2, sticky="ew")

    del_btn = ctk.CTkButton(
        btn_frame, 
        text="ğŸ—‘ï¸ åˆ é™¤", 
        command=delete_current_config,
        font=("Microsoft YaHei", 12),
        fg_color="#8B0000",
        width=80
    )
    del_btn.grid(row=0, column=2, padx=2, pady=2, sticky="ew")

    save_btn = ctk.CTkButton(
        btn_frame, 
        text="ğŸ’¾ ä¿å­˜", 
        command=save_current_config,
        font=("Microsoft YaHei", 12),
        fg_color="#1E90FF",
        width=80
    )
    save_btn.grid(row=0, column=3, padx=2, pady=2, sticky="ew")

    # é…ç½®å‚æ•°æ§ä»¶
    row_start = 2
    # 1) API Key
    create_label_with_help(self, self.ai_config_tab, "API Key:", "api_key", row_start, 0)
    self.api_key_var = ctk.StringVar(value="")
    api_key_entry = ctk.CTkEntry(
        self.ai_config_tab, 
        textvariable=self.api_key_var,
        font=("Microsoft YaHei", 12),
        show="*"
    )
    api_key_entry.grid(row=row_start, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")
    
    # 2) Base URL
    create_label_with_help(self, self.ai_config_tab, "Base URL:", "base_url", row_start+1, 0)
    self.base_url_var = ctk.StringVar(value="")
    base_url_entry = ctk.CTkEntry(
        self.ai_config_tab, 
        textvariable=self.base_url_var,
        font=("Microsoft YaHei", 12)
    )
    base_url_entry.grid(row=row_start+1, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")
    
    # 3) æ¥å£æ ¼å¼
    create_label_with_help(self, self.ai_config_tab, "æ¥å£æ ¼å¼:", "interface_format", row_start+2, 0)
    self.interface_format_var = ctk.StringVar(value="OpenAI")
    interface_options = ["OpenAI", "Azure OpenAI", "Ollama", "DeepSeek", "Gemini", "ML Studio", "ç¡…åŸºæµåŠ¨"]
    interface_dropdown = ctk.CTkOptionMenu(
        self.ai_config_tab,
        values=interface_options,
        variable=self.interface_format_var,
        font=("Microsoft YaHei", 12)
    )
    interface_dropdown.grid(row=row_start+2, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")
    
    # 4) Model Name
    create_label_with_help(self, self.ai_config_tab, "æ¨¡å‹åç§°:", "model_name", row_start+3, 0)
    self.model_name_var = ctk.StringVar(value="")
    model_name_entry = ctk.CTkEntry(
        self.ai_config_tab, 
        textvariable=self.model_name_var,
        font=("Microsoft YaHei", 12)
    )
    model_name_entry.grid(row=row_start+3, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")
    
    # 5) Temperature
    create_label_with_help(self, self.ai_config_tab, "Temperature:", "temperature", row_start+4, 0)
    self.temperature_var = ctk.DoubleVar(value=0.7)
    def update_temp_label(value):
        self.temp_value_label.configure(text=f"{float(value):.2f}")
    temp_scale = ctk.CTkSlider(
        self.ai_config_tab, 
        from_=0, 
        to=2, 
        number_of_steps=200, 
        command=update_temp_label,
        variable=self.temperature_var
    )
    temp_scale.grid(row=row_start+4, column=1, padx=5, pady=5, sticky="we")
    self.temp_value_label = ctk.CTkLabel(
        self.ai_config_tab, 
        text=f"{self.temperature_var.get():.2f}",
        font=("Microsoft YaHei", 12)
    )
    self.temp_value_label.grid(row=row_start+4, column=2, padx=5, pady=5, sticky="w")
    
    # 6) Max Tokens
    create_label_with_help(self, self.ai_config_tab, "Max Tokens:", "max_tokens", row_start+5, 0)
    self.max_tokens_var = ctk.IntVar(value=8192)
    def update_max_tokens_label(value):
        self.max_tokens_value_label.configure(text=str(int(float(value))))
    max_tokens_slider = ctk.CTkSlider(
        self.ai_config_tab, 
        from_=0, 
        to=102400, 
        number_of_steps=100, 
        command=update_max_tokens_label,
        variable=self.max_tokens_var
    )
    max_tokens_slider.grid(row=row_start+5, column=1, padx=5, pady=5, sticky="we")
    self.max_tokens_value_label = ctk.CTkLabel(
        self.ai_config_tab, 
        text=str(self.max_tokens_var.get()),
        font=("Microsoft YaHei", 12)
    )
    self.max_tokens_value_label.grid(row=row_start+5, column=2, padx=5, pady=5, sticky="w")
    
    # 7) Timeout
    create_label_with_help(self, self.ai_config_tab, "Timeout (sec):", "timeout", row_start+6, 0)
    self.timeout_var = ctk.IntVar(value=600)
    def update_timeout_label(value):
        self.timeout_value_label.configure(text=str(int(float(value))))
    timeout_slider = ctk.CTkSlider(
        self.ai_config_tab, 
        from_=0, 
        to=3600, 
        number_of_steps=3600, 
        command=update_timeout_label,
        variable=self.timeout_var
    )
    timeout_slider.grid(row=row_start+6, column=1, padx=5, pady=5, sticky="we")
    self.timeout_value_label = ctk.CTkLabel(
        self.ai_config_tab, 
        text=str(self.timeout_var.get()),
        font=("Microsoft YaHei", 12)
    )
    self.timeout_value_label.grid(row=row_start+6, column=2, padx=5, pady=5, sticky="w")
    
    # æµ‹è¯•æŒ‰é’®
    test_btn = ctk.CTkButton(
        self.ai_config_tab, 
        text="æµ‹è¯•é…ç½®", 
        command=self.test_llm_config,
        font=("Microsoft YaHei", 12)
    )
    test_btn.grid(row=row_start+7, column=0, columnspan=3, padx=5, pady=5, sticky="ew")

    # åˆå§‹åŒ–å½“å‰é…ç½®
    on_config_selected(config_names[0])


    # åˆå§‹åŒ–UIå¸ƒå±€
    for i in range(10):  # å¢åŠ ä¸€è¡Œç»™æŒ‰é’®ç»„
        self.ai_config_tab.grid_rowconfigure(i, weight=0)
    self.ai_config_tab.grid_columnconfigure(0, weight=0)
    self.ai_config_tab.grid_columnconfigure(1, weight=1)
    self.ai_config_tab.grid_columnconfigure(2, weight=0)

    # é…ç½®é€‰æ‹©æ§ä»¶
    create_label_with_help(self, self.ai_config_tab, "å½“å‰é…ç½®", "interface_config", 0, 0)
    config_names = list(self.loaded_config.get("llm_configs", {}).keys())
    if not config_names:  # å¦‚æœæ²¡æœ‰é…ç½®ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤é…ç½®
        self.loaded_config["llm_configs"] = {
            "é»˜è®¤é…ç½®": {
                "id": str(uuid.uuid4()),
                "api_key": "",
                "base_url": "https://api.openai.com/v1",
                "model_name": "gpt-4",
                "temperature": 0.7,
                "max_tokens": 8192,
                "timeout": 600,
                "interface_format": "OpenAI",
                "created_at": datetime.datetime.now().isoformat()
            }
        }
        config_names = ["é»˜è®¤é…ç½®"]
    
    interface_config_dropdown = ctk.CTkOptionMenu(
        self.ai_config_tab, 
        values=config_names,
        variable=self.interface_config_var,
        command=on_config_selected,
        font=("Microsoft YaHei", 12)
    )
    interface_config_dropdown.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="nsew")

def build_embeddings_config_tab(self):
    def on_embedding_interface_changed(new_value):
        self.embedding_interface_format_var.set(new_value)
        config_data = load_config(self.config_file)
        if config_data:
            config_data["last_embedding_interface_format"] = new_value
            save_config(config_data, self.config_file)
        if self.loaded_config and "embedding_configs" in self.loaded_config and new_value in self.loaded_config["embedding_configs"]:
            emb_conf = self.loaded_config["embedding_configs"][new_value]
            self.embedding_api_key_var.set(emb_conf.get("api_key", ""))
            self.embedding_url_var.set(emb_conf.get("base_url", self.embedding_url_var.get()))
            self.embedding_model_name_var.set(emb_conf.get("model_name", ""))
            self.embedding_retrieval_k_var.set(str(emb_conf.get("retrieval_k", 4)))
        else:
            if new_value == "Ollama":
                self.embedding_url_var.set("http://localhost:11434/api")
            elif new_value == "ML Studio":
                self.embedding_url_var.set("http://localhost:1234/v1")
            elif new_value == "OpenAI":
                self.embedding_url_var.set("https://api.openai.com/v1")
                self.embedding_model_name_var.set("text-embedding-ada-002")
            elif new_value == "Azure OpenAI":
                self.embedding_url_var.set("https://[az].openai.azure.com/openai/deployments/[model]/embeddings?api-version=2023-05-15")
            elif new_value == "DeepSeek":
                self.embedding_url_var.set("https://api.deepseek.com/v1")
            elif new_value == "Gemini":
                self.embedding_url_var.set("https://generativelanguage.googleapis.com/v1beta/")
                self.embedding_model_name_var.set("models/text-embedding-004")
            elif new_value == "SiliconFlow":
                self.embedding_url_var.set("https://api.siliconflow.cn/v1/embeddings")
                self.embedding_model_name_var.set("BAAI/bge-m3")

    for i in range(5):
        self.embeddings_config_tab.grid_rowconfigure(i, weight=0)
    self.embeddings_config_tab.grid_columnconfigure(0, weight=0)
    self.embeddings_config_tab.grid_columnconfigure(1, weight=1)
    self.embeddings_config_tab.grid_columnconfigure(2, weight=0)

    # 1) Embedding API Key
    create_label_with_help(self, parent=self.embeddings_config_tab, label_text="Embedding API Key:", tooltip_key="embedding_api_key", row=0, column=0, font=("Microsoft YaHei", 12))
    emb_api_key_entry = ctk.CTkEntry(self.embeddings_config_tab, textvariable=self.embedding_api_key_var, font=("Microsoft YaHei", 12), show="*")
    emb_api_key_entry.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")

    # 2) Embedding æ¥å£æ ¼å¼
    create_label_with_help(self, parent=self.embeddings_config_tab, label_text="Embedding æ¥å£æ ¼å¼:", tooltip_key="embedding_intexrface_format", row=1, column=0, font=("Microsoft YaHei", 12))

    emb_interface_options = ["DeepSeek", "OpenAI", "Azure OpenAI", "Gemini", "Ollama", "ML Studio","SiliconFlow"]

    emb_interface_dropdown = ctk.CTkOptionMenu(self.embeddings_config_tab, values=emb_interface_options, variable=self.embedding_interface_format_var, command=on_embedding_interface_changed, font=("Microsoft YaHei", 12))
    emb_interface_dropdown.grid(row=1, column=1, padx=5, pady=5, sticky="nsew")

    # 3) Embedding Base URL
    create_label_with_help(self, parent=self.embeddings_config_tab, label_text="Embedding Base URL:", tooltip_key="embedding_url", row=2, column=0, font=("Microsoft YaHei", 12))
    emb_url_entry = ctk.CTkEntry(self.embeddings_config_tab, textvariable=self.embedding_url_var, font=("Microsoft YaHei", 12))
    emb_url_entry.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

    # 4) Embedding Model Name
    create_label_with_help(self, parent=self.embeddings_config_tab, label_text="Embedding Model Name:", tooltip_key="embedding_model_name", row=3, column=0, font=("Microsoft YaHei", 12))
    emb_model_name_entry = ctk.CTkEntry(self.embeddings_config_tab, textvariable=self.embedding_model_name_var, font=("Microsoft YaHei", 12))
    emb_model_name_entry.grid(row=3, column=1, padx=5, pady=5, sticky="nsew")

    # 5) Retrieval Top-K
    create_label_with_help(self, parent=self.embeddings_config_tab, label_text="Retrieval Top-K:", tooltip_key="embedding_retrieval_k", row=4, column=0, font=("Microsoft YaHei", 12))
    emb_retrieval_k_entry = ctk.CTkEntry(self.embeddings_config_tab, textvariable=self.embedding_retrieval_k_var, font=("Microsoft YaHei", 12))
    emb_retrieval_k_entry.grid(row=4, column=1, padx=5, pady=5, sticky="nsew")

    # æ·»åŠ æµ‹è¯•æŒ‰é’®
    test_btn = ctk.CTkButton(self.embeddings_config_tab, text="æµ‹è¯•é…ç½®", command=self.test_embedding_config, font=("Microsoft YaHei", 12))
    test_btn.grid(row=5, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

def build_config_choose_tab(self):
    """
    æ„å»ºã€æ¨¡å‹æŒ‡æ´¾ã€‘ç•Œé¢çš„å…·ä½“å†…å®¹
    """
    self.config_choose.grid_rowconfigure(0, weight=0)
    self.config_choose.grid_columnconfigure(0, weight=0)
    self.config_choose.grid_columnconfigure(1, weight=1)

    # è·å–é…ç½®åˆ—è¡¨
    config_choose_options = list(self.loaded_config.get("llm_configs", {}).keys())
    if not config_choose_options:
        config_choose_options = ["Default"]

    # --- è¾…åŠ©ï¼šç¡®ä¿å˜é‡å·²åˆå§‹åŒ– ---
    def ensure_var(var_name, default_val=None):
        if not hasattr(self, var_name):
            val = default_val if default_val else config_choose_options[0]
            setattr(self, var_name, ctk.StringVar(value=val))
        # å†æ¬¡æ£€æŸ¥å€¼æ˜¯å¦æœ‰æ•ˆ
        var = getattr(self, var_name)
        if var.get() not in config_choose_options:
            var.set(config_choose_options[0])

    # åˆå§‹åŒ–æ‰€æœ‰éœ€è¦çš„å˜é‡
    ensure_var("architecture_llm_var")
    ensure_var("chapter_outline_llm_var")
    ensure_var("prompt_draft_llm_var")
    ensure_var("refine_logic_llm_var")    # æ–°å¢
    ensure_var("final_chapter_llm_var")   # æ–°å¢
    ensure_var("consistency_review_llm_var")

    # 1. æ¶æ„æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="ç”Ÿæˆæ¶æ„æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="architecture_llm_config", row=0, column=0, font=("Microsoft YaHei", 12))
    architecture_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.architecture_llm_var, font=("Microsoft YaHei", 12))
    architecture_dropdown.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")

    # 2. ç›®å½•æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="ç”Ÿæˆå¤§ç›®å½•æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="chapter_outline_llm_config", row=1, column=0, font=("Microsoft YaHei", 12))
    chapter_outline_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.chapter_outline_llm_var, font=("Microsoft YaHei", 12))
    chapter_outline_dropdown.grid(row=1, column=1, padx=5, pady=5, sticky="nsew")

    # 3. è‰ç¨¿æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="ç”Ÿæˆè‰ç¨¿æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="prompt_draft_llm_config", row=2, column=0, font=("Microsoft YaHei", 12))
    prompt_draft_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.prompt_draft_llm_var, font=("Microsoft YaHei", 12))
    prompt_draft_dropdown.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

    # 4. ã€æ–°å¢ã€‘é€»è¾‘/é€‰è§’æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="é€»è¾‘/é€‰è§’æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="refine_logic_llm_config", row=3, column=0, font=("Microsoft YaHei", 12))
    refine_logic_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.refine_logic_llm_var, font=("Microsoft YaHei", 12))
    refine_logic_dropdown.grid(row=3, column=1, padx=5, pady=5, sticky="nsew")

    # 5. ã€æ–°å¢ã€‘å®šç¨¿æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="å®šç¨¿ç« èŠ‚æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="final_chapter_llm_config", row=4, column=0, font=("Microsoft YaHei", 12))
    final_chapter_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.final_chapter_llm_var, font=("Microsoft YaHei", 12))
    final_chapter_dropdown.grid(row=4, column=1, padx=5, pady=5, sticky="nsew")

    # 6. å®¡æ ¡æ¨¡å‹
    create_label_with_help(self, parent=self.config_choose, label_text="ä¸€è‡´æ€§å®¡æ ¡æ‰€ç”¨å¤§æ¨¡å‹", tooltip_key="consistency_review_llm_config", row=5, column=0, font=("Microsoft YaHei", 12))
    consistency_review_dropdown = ctk.CTkOptionMenu(self.config_choose, values=config_choose_options, variable=self.consistency_review_llm_var, font=("Microsoft YaHei", 12))
    consistency_review_dropdown.grid(row=5, column=1, padx=5, pady=5, sticky="nsew")


    # --- åŠŸèƒ½å‡½æ•° ---
    def save_config_choose():
        full_config = load_config(self.config_file)
        if "choose_configs" not in full_config:
            full_config["choose_configs"] = {}
        
        config_data = full_config["choose_configs"]
        config_data["architecture_llm"] = self.architecture_llm_var.get()
        config_data["chapter_outline_llm"] = self.chapter_outline_llm_var.get()
        config_data["prompt_draft_llm"] = self.prompt_draft_llm_var.get()
        
        # ä¿å­˜æ–°å¢é¡¹
        config_data["refine_logic_llm"] = self.refine_logic_llm_var.get()
        config_data["final_chapter_llm"] = self.final_chapter_llm_var.get()
        
        config_data["consistency_review_llm"] = self.consistency_review_llm_var.get()

        full_config["choose_configs"] = config_data
        save_config(full_config, self.config_file)
        messagebox.showinfo("æç¤º", "æ¨¡å‹æŒ‡æ´¾é…ç½®å·²ä¿å­˜ã€‚")

    def refresh_config_dropdowns():
        """åˆ·æ–°æ‰€æœ‰é…ç½®ä¸‹æ‹‰èœå•"""
        config_names = list(self.loaded_config.get("llm_configs", {}).keys())
        if not config_names: config_names = ["Default"]
        
        dropdowns = [
            architecture_dropdown, chapter_outline_dropdown, prompt_draft_dropdown,
            refine_logic_dropdown, final_chapter_dropdown, consistency_review_dropdown
        ]
        
        for dropdown in dropdowns:
            dropdown.configure(values=config_names)
            if dropdown.cget("variable").get() not in config_names:
                dropdown.cget("variable").set(config_names[0])

    # --- æŒ‰é’® ---
    save_btn = ctk.CTkButton(
        self.config_choose, 
        text="ä¿å­˜é…ç½®", 
        command=save_config_choose,
        font=("Microsoft YaHei", 12)
    )
    save_btn.grid(row=10, column=0, padx=2, pady=10, sticky="ew")

    refresh_btn = ctk.CTkButton(
        self.config_choose, 
        text="åˆ·æ–°é…ç½®", 
        command=refresh_config_dropdowns,
        font=("Microsoft YaHei", 12)
    )
    refresh_btn.grid(row=10, column=1, padx=2, pady=10, sticky="ew")



# PenBo å¢åŠ ä»£ç†åŠŸèƒ½æ”¯æŒ
def build_proxy_setting_tab(self):
    # ä»£ç†è®¾ç½®æ ‡ç­¾é¡µå¸ƒå±€
    for i in range(5):
        self.proxy_setting_tab.grid_rowconfigure(i, weight=0)
    self.proxy_setting_tab.grid_columnconfigure(0, weight=0)
    self.proxy_setting_tab.grid_columnconfigure(1, weight=1)

    # ä»é…ç½®æ–‡ä»¶åŠ è½½ä»£ç†è®¾ç½®
    config_data = load_config(self.config_file)
    proxy_setting = config_data.get("proxy_setting", {})
    
    # ä»£ç†å¯ç”¨å¼€å…³
    create_label_with_help(self, self.proxy_setting_tab, "å¯ç”¨ä»£ç†:", "proxy_enabled", 0, 0)
    self.proxy_enabled_var = ctk.BooleanVar(value=proxy_setting.get("enabled", False))
    proxy_enabled_switch = ctk.CTkSwitch(
        self.proxy_setting_tab,
        text="",
        variable=self.proxy_enabled_var,
        onvalue=True,
        offvalue=False,
        font=("Microsoft YaHei", 12)
    )
    proxy_enabled_switch.grid(row=0, column=1, padx=5, pady=5, sticky="w")

    # åœ°å€è¾“å…¥æ¡†
    create_label_with_help(self, self.proxy_setting_tab, "åœ°å€:", "proxy_address", 1, 0)
    self.proxy_address_var = ctk.StringVar(value=proxy_setting.get("proxy_url", "127.0.0.1"))
    proxy_address_entry = ctk.CTkEntry(
        self.proxy_setting_tab,
        textvariable=self.proxy_address_var,
        font=("Microsoft YaHei", 12)
    )
    proxy_address_entry.grid(row=1, column=1, padx=5, pady=5, sticky="nsew")

    # ç«¯å£è¾“å…¥æ¡†
    create_label_with_help(self, self.proxy_setting_tab, "ç«¯å£:", "proxy_port", 2, 0)
    self.proxy_port_var = ctk.StringVar(value=proxy_setting.get("proxy_port", "10809"))
    proxy_port_entry = ctk.CTkEntry(
        self.proxy_setting_tab,
        textvariable=self.proxy_port_var,
        font=("Microsoft YaHei", 12)
    )
    proxy_port_entry.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")


    def open_proxy(address, port):
        """å¯åŠ¨ä»£ç†"""
        # è®¾ç½®ç¯å¢ƒå˜é‡
        os.environ['HTTP_PROXY'] = f"http://{address}:{port}"
        os.environ['HTTPS_PROXY'] = f"http://{address}:{port}"

    def save_proxy_setting():
        config_data = load_config(self.config_file)
        if "proxy_setting" not in config_data:
            config_data["proxy_setting"] = {}
            
        config_data["proxy_setting"]["enabled"] = self.proxy_enabled_var.get()
        config_data["proxy_setting"]["proxy_url"] = self.proxy_address_var.get()
        config_data["proxy_setting"]["proxy_port"] = self.proxy_port_var.get()

        save_config(config_data, self.config_file)
        messagebox.showinfo("æç¤º", "ä»£ç†é…ç½®å·²ä¿å­˜ã€‚")

        if self.proxy_enabled_var.get():
            open_proxy(self.proxy_address_var.get(), self.proxy_port_var.get())
        else:
            os.environ.pop('HTTP_PROXY', None)
            os.environ.pop('HTTPS_PROXY', None)

    # æ·»åŠ ä¿å­˜æŒ‰é’®
    save_btn = ctk.CTkButton(
        self.proxy_setting_tab,
        text="ä¿å­˜ä»£ç†è®¾ç½®",
        command=save_proxy_setting,
        font=("Microsoft YaHei", 12)
    )
    save_btn.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")


    

def load_config_btn(self):
    cfg = load_config(self.config_file)
    if cfg:
        last_llm = cfg.get("last_interface_format", "OpenAI")
        last_embedding = cfg.get("last_embedding_interface_format", "OpenAI")
        self.interface_format_var.set(last_llm)
        self.embedding_interface_format_var.set(last_embedding)
        llm_configs = cfg.get("llm_configs", {})
        if last_llm in llm_configs:
            llm_conf = llm_configs[last_llm]
            self.interface_format_var.set(llm_conf.get("interface_format", "OpenAI"))
            self.api_key_var.set(llm_conf.get("api_key", ""))
            self.base_url_var.set(llm_conf.get("base_url", "https://api.openai.com/v1"))
            self.model_name_var.set(llm_conf.get("model_name", "gpt-4o-mini"))
            self.temperature_var.set(llm_conf.get("temperature", 0.7))
            self.max_tokens_var.set(llm_conf.get("max_tokens", 8192))
            self.timeout_var.set(llm_conf.get("timeout", 600))
        embedding_configs = cfg.get("embedding_configs", {})
        if last_embedding in embedding_configs:
            emb_conf = embedding_configs[last_embedding]
            self.embedding_api_key_var.set(emb_conf.get("api_key", ""))
            self.embedding_url_var.set(emb_conf.get("base_url", "https://api.openai.com/v1"))
            self.embedding_model_name_var.set(emb_conf.get("model_name", "text-embedding-ada-002"))
            self.embedding_retrieval_k_var.set(str(emb_conf.get("retrieval_k", 4)))
        other_params = cfg.get("other_params", {})
        self.topic_text.delete("0.0", "end")
        self.topic_text.insert("0.0", other_params.get("topic", ""))
        self.genre_var.set(other_params.get("genre", "ç„å¹»"))
        self.num_chapters_var.set(str(other_params.get("num_chapters", 10)))
        self.word_number_var.set(str(other_params.get("word_number", 3000)))
        self.filepath_var.set(other_params.get("filepath", ""))
        self.chapter_num_var.set(str(other_params.get("chapter_num", "1")))
        self.user_guide_text.delete("0.0", "end")
        self.user_guide_text.insert("0.0", other_params.get("user_guidance", ""))
        self.characters_involved_var.set(other_params.get("characters_involved", ""))
        self.key_items_var.set(other_params.get("key_items", ""))
        self.scene_location_var.set(other_params.get("scene_location", ""))
        self.time_constraint_var.set(other_params.get("time_constraint", ""))
        self.log("å·²åŠ è½½é…ç½®ã€‚")
    else:
        messagebox.showwarning("æç¤º", "æœªæ‰¾åˆ°æˆ–æ— æ³•è¯»å–é…ç½®æ–‡ä»¶ã€‚")

def save_config_btn(self):
    current_llm_interface = self.interface_format_var.get().strip()
    current_embedding_interface = self.embedding_interface_format_var.get().strip()
    llm_config = {
        "api_key": self.api_key_var.get(),
        "base_url": self.base_url_var.get(),
        "model_name": self.model_name_var.get(),
        "temperature": self.temperature_var.get(),
        "max_tokens": self.max_tokens_var.get(),
        "timeout": self.safe_get_int(self.timeout_var, 600),
        "interface_format": current_llm_interface
    }
    embedding_config = {
        "api_key": self.embedding_api_key_var.get(),
        "base_url": self.embedding_url_var.get(),
        "model_name": self.embedding_model_name_var.get(),
        "retrieval_k": self.safe_get_int(self.embedding_retrieval_k_var, 4),
        "interface_format": current_embedding_interface

    }
    other_params = {
        "topic": self.topic_text.get("0.0", "end").strip(),
        "genre": self.genre_var.get(),
        "num_chapters": self.safe_get_int(self.num_chapters_var, 10),
        "word_number": self.safe_get_int(self.word_number_var, 3000),
        "filepath": self.filepath_var.get(),
        "chapter_num": self.chapter_num_var.get(),
        "user_guidance": self.user_guide_text.get("0.0", "end").strip(),
        "characters_involved": self.characters_involved_var.get(),
        "key_items": self.key_items_var.get(),
        "scene_location": self.scene_location_var.get(),
        "time_constraint": self.time_constraint_var.get()
    }
    llm_config_name = self.base_url_var.get().split("/")[2] + " " + self.model_name_var.get()

    existing_config = load_config(self.config_file)
    if not existing_config:
        existing_config = {}
    existing_config["last_interface_format"] = current_llm_interface
    existing_config["last_embedding_interface_format"] = current_embedding_interface
    if "llm_configs" not in existing_config:
        existing_config["llm_configs"] = {}
    llm_config["config_name"] = llm_config_name

    existing_config["llm_configs"][llm_config_name] = llm_config

    if "embedding_configs" not in existing_config:
        existing_config["embedding_configs"] = {}
    existing_config["embedding_configs"][current_embedding_interface] = embedding_config

    existing_config["other_params"] = other_params

    if save_config(existing_config, self.config_file):
        messagebox.showinfo("æç¤º", "é…ç½®å·²ä¿å­˜è‡³ config.json")
        self.log("é…ç½®å·²ä¿å­˜ã€‚")
    else:
        messagebox.showerror("é”™è¯¯", "ä¿å­˜é…ç½®å¤±è´¥ã€‚")
</file>

<file path="ui/generation_handlers.py">
# ui/generation_handlers.py
# -*- coding: utf-8 -*-
import os
import re
import threading
import tkinter as tk
from tkinter import messagebox, filedialog
import customtkinter as ctk
import traceback
import glob
from utils import read_file, save_string_to_txt, clear_file_content
from novel_generator import (
    Novel_architecture_generate,
    Chapter_blueprint_generate,
    generate_chapter_draft,
    finalize_chapter,
    import_knowledge_file,
    clear_vector_store,
    enrich_chapter_text,
    build_chapter_prompt,
    analyze_chapter_logic,
    rewrite_chapter_with_feedback,
    refine_chapter_detail,
    answer_novel_question
)
from consistency_checker import check_consistency

def generate_novel_architecture_ui(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return

    def task():
        confirm = messagebox.askyesno("ç¡®è®¤", "ç¡®å®šè¦ç”Ÿæˆå°è¯´æ¶æ„å—ï¼Ÿ")
        if not confirm:
            self.enable_button_safe(self.btn_generate_architecture)
            return

        self.disable_button_safe(self.btn_generate_architecture)
        try:


            interface_format = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["interface_format"]
            api_key = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["api_key"]
            base_url = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["base_url"]
            model_name = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["model_name"]
            temperature = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["temperature"]
            max_tokens = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["max_tokens"]
            timeout_val = self.loaded_config["llm_configs"][self.architecture_llm_var.get()]["timeout"]



            topic = self.topic_text.get("0.0", "end").strip()
            genre = self.genre_var.get().strip()
            num_chapters = self.safe_get_int(self.num_chapters_var, 10)
            word_number = self.safe_get_int(self.word_number_var, 3000)
            # è·å–å†…å®¹æŒ‡å¯¼
            user_guidance = self.user_guide_text.get("0.0", "end").strip()

            self.safe_log("å¼€å§‹ç”Ÿæˆå°è¯´æ¶æ„...")
            Novel_architecture_generate(
                interface_format=interface_format,
                api_key=api_key,
                base_url=base_url,
                llm_model=model_name,
                topic=topic,
                genre=genre,
                number_of_chapters=num_chapters,
                word_number=word_number,
                filepath=filepath,
                temperature=temperature,
                max_tokens=max_tokens,
                timeout=timeout_val,
                user_guidance=user_guidance  # æ·»åŠ å†…å®¹æŒ‡å¯¼å‚æ•°
            )
            self.safe_log("âœ… å°è¯´æ¶æ„ç”Ÿæˆå®Œæˆã€‚è¯·åœ¨ 'Novel Architecture' æ ‡ç­¾é¡µæŸ¥çœ‹æˆ–ç¼–è¾‘ã€‚")
        except Exception:
            self.handle_exception("ç”Ÿæˆå°è¯´æ¶æ„æ—¶å‡ºé”™")
        finally:
            self.enable_button_safe(self.btn_generate_architecture)
    threading.Thread(target=task, daemon=True).start()

def generate_chapter_blueprint_ui(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé€‰æ‹©ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return

    def task():
        if not messagebox.askyesno("ç¡®è®¤", "ç¡®å®šè¦ç”Ÿæˆç« èŠ‚ç›®å½•å—ï¼Ÿ"):
            self.enable_button_safe(self.btn_generate_chapter)
            return
        self.disable_button_safe(self.btn_generate_directory)
        try:

            number_of_chapters = self.safe_get_int(self.num_chapters_var, 10)

            interface_format = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["interface_format"]
            api_key = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["api_key"]
            base_url = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["base_url"]
            model_name = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["model_name"]
            temperature = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["temperature"]
            max_tokens = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["max_tokens"]
            timeout_val = self.loaded_config["llm_configs"][self.chapter_outline_llm_var.get()]["timeout"]


            user_guidance = self.user_guide_text.get("0.0", "end").strip()  # æ–°å¢è·å–ç”¨æˆ·æŒ‡å¯¼

            self.safe_log("å¼€å§‹ç”Ÿæˆç« èŠ‚è“å›¾...")
            Chapter_blueprint_generate(
                interface_format=interface_format,
                api_key=api_key,
                base_url=base_url,
                llm_model=model_name,
                number_of_chapters=number_of_chapters,
                filepath=filepath,
                temperature=temperature,
                max_tokens=max_tokens,
                timeout=timeout_val,
                user_guidance=user_guidance  # æ–°å¢å‚æ•°
            )
            self.safe_log("âœ… ç« èŠ‚è“å›¾ç”Ÿæˆå®Œæˆã€‚è¯·åœ¨ 'Chapter Blueprint' æ ‡ç­¾é¡µæŸ¥çœ‹æˆ–ç¼–è¾‘ã€‚")
        except Exception:
            self.handle_exception("ç”Ÿæˆç« èŠ‚è“å›¾æ—¶å‡ºé”™")
        finally:
            self.enable_button_safe(self.btn_generate_directory)
    threading.Thread(target=task, daemon=True).start()

def generate_chapter_draft_ui(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return

    def task():
        self.disable_button_safe(self.btn_generate_chapter)
        try:
            # === 1. å‡†å¤‡å¤§æ¨¡å‹å‚æ•° ===
            # ç”Ÿæˆç”¨çš„ LLM é…ç½®
            draft_config_key = self.prompt_draft_llm_var.get()
            draft_config = self.loaded_config["llm_configs"][draft_config_key]
            
            draft_interface = draft_config["interface_format"]
            draft_key = draft_config["api_key"]
            draft_url = draft_config["base_url"]
            draft_model = draft_config["model_name"]
            draft_temp = draft_config["temperature"]
            draft_tokens = draft_config["max_tokens"]
            draft_timeout = draft_config["timeout"]

            # è‡ªæ£€ç”¨çš„ LLM é…ç½® (å»ºè®®ä½¿ç”¨ä¸€è‡´æ€§å®¡æ ¡çš„æ¨¡å‹ï¼Œé€šå¸¸é€»è¾‘æ›´å¼º)
            review_config_key = self.refine_logic_llm_var.get() 
            review_config = self.loaded_config["llm_configs"][review_config_key]
            
            review_interface = review_config["interface_format"]
            review_key = review_config["api_key"]
            review_url = review_config["base_url"]
            review_model = review_config["model_name"]
            # è¡¥å……å®¡æ ¡æ¨¡å‹çš„å¯é€‰å‚æ•°
            review_temp = review_config.get("temperature", 0.3)
            review_tokens = review_config.get("max_tokens", draft_tokens)
            
            # Embedding å‚æ•°
            emb_key = self.embedding_api_key_var.get().strip()
            emb_url = self.embedding_url_var.get().strip()
            emb_fmt = self.embedding_interface_format_var.get().strip()
            emb_model = self.embedding_model_name_var.get().strip()
            emb_k = self.safe_get_int(self.embedding_retrieval_k_var, 4)

            # ç« èŠ‚å‚æ•°
            chap_num = self.safe_get_int(self.chapter_num_var, 1)
            word_num = self.safe_get_int(self.word_number_var, 3000)
            user_guide = self.user_guide_text.get("0.0", "end").strip()
            char_inv = self.characters_involved_var.get().strip()
            key_items = self.key_items_var.get().strip()
            scene_loc = self.scene_location_var.get().strip()
            time_constr = self.time_constraint_var.get().strip()

            self.safe_log(f"æ¨¡å‹ï¼š{draft_model}ï¼Œæ­£åœ¨ç”Ÿæˆç¬¬{chap_num}ç« è‰ç¨¿æç¤ºè¯...")

            # === 2. æ„é€ æç¤ºè¯å¹¶è®©ç”¨æˆ·ç¡®è®¤ ===
            prompt_text = build_chapter_prompt(
                api_key=draft_key, base_url=draft_url, model_name=draft_model,
                filepath=filepath, novel_number=chap_num, word_number=word_num,
                temperature=draft_temp, user_guidance=user_guide,
                characters_involved=char_inv, key_items=key_items,
                scene_location=scene_loc, time_constraint=time_constr,
                embedding_api_key=emb_key, embedding_url=emb_url,
                embedding_interface_format=emb_fmt, embedding_model_name=emb_model,
                embedding_retrieval_k=emb_k, interface_format=draft_interface,
                max_tokens=draft_tokens, timeout=draft_timeout
            )

            # å¼¹å‡ºç¡®è®¤æ¡†é€»è¾‘ (å«å­—æ•°ç»Ÿè®¡)
            result: dict[str, str | None] = {"prompt": None}
            event = threading.Event()

            def create_prompt_dialog():
                dialog = ctk.CTkToplevel(self.master)
                dialog.title("ç¡®è®¤æç¤ºè¯")
                dialog.geometry("800x600")
                
                # é¡¶éƒ¨æ ï¼šæ ‡é¢˜ + å­—æ•°ç»Ÿè®¡
                header_frame = ctk.CTkFrame(dialog, fg_color="transparent")
                header_frame.pack(fill="x", padx=10, pady=(10,0))
                ctk.CTkLabel(header_frame, text="ç”Ÿæˆæç¤ºè¯å†…å®¹", font=("Microsoft YaHei", 12, "bold")).pack(side="left")
                prompt_wc_label = ctk.CTkLabel(header_frame, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
                prompt_wc_label.pack(side="right")

                text_box = ctk.CTkTextbox(dialog, wrap="word", font=("Microsoft YaHei", 12))
                text_box.pack(fill="both", expand=True, padx=10, pady=5)
                
                # å¤„ç†è§’è‰²å†…å®¹æ’å…¥ (ä¿æŒåŸæœ‰é€»è¾‘)
                final_prompt = prompt_text
                role_names = [name.strip() for name in self.char_inv_text.get("0.0", "end").strip().split(',') if name.strip()]
                role_lib_path = os.path.join(filepath, "è§’è‰²åº“")
                role_contents = []
                
                if os.path.exists(role_lib_path):
                    for root, dirs, files in os.walk(role_lib_path):
                        for file in files:
                            if file.endswith(".txt") and os.path.splitext(file)[0] in role_names:
                                try:
                                    with open(os.path.join(root, file), 'r', encoding='utf-8') as f:
                                        role_contents.append(f.read().strip())
                                except Exception: pass
                
                if role_contents:
                    role_content_str = "\n".join(role_contents)
                    placeholder_variations = [
                        "æ ¸å¿ƒäººç‰©(å¯èƒ½æœªæŒ‡å®š)ï¼š{characters_involved}",
                        "æ ¸å¿ƒäººç‰©ï¼š{characters_involved}",
                        "æ ¸å¿ƒäººç‰©:{characters_involved}"
                    ]
                    for ph in placeholder_variations:
                        if ph in final_prompt:
                            final_prompt = final_prompt.replace(ph, f"æ ¸å¿ƒäººç‰©ï¼š\n{role_content_str}")
                            break
                    else:
                        lines = final_prompt.split('\n')
                        for i, line in enumerate(lines):
                            if "æ ¸å¿ƒäººç‰©" in line and "ï¼š" in line:
                                lines[i] = f"æ ¸å¿ƒäººç‰©ï¼š\n{role_content_str}"
                                break
                        final_prompt = '\n'.join(lines)

                text_box.insert("0.0", final_prompt)
                
                # æç¤ºè¯å­—æ•°æ›´æ–°é€»è¾‘
                def update_prompt_wc(e=None):
                    t = text_box.get("0.0", "end-1c")
                    prompt_wc_label.configure(text=f"å­—æ•°ï¼š{len(t)}")
                text_box.bind("<KeyRelease>", update_prompt_wc)
                update_prompt_wc() # åˆå§‹åŒ–

                btn_frame = ctk.CTkFrame(dialog)
                btn_frame.pack(pady=10)
                
                def on_confirm():
                    result["prompt"] = text_box.get("1.0", "end").strip()
                    dialog.destroy()
                    event.set()
                
                def on_cancel():
                    dialog.destroy()
                    event.set()

                ctk.CTkButton(btn_frame, text="ç”Ÿæˆè‰ç¨¿", command=on_confirm).pack(side="left", padx=10)
                ctk.CTkButton(btn_frame, text="å–æ¶ˆ", command=on_cancel, fg_color="gray").pack(side="left", padx=10)
                dialog.protocol("WM_DELETE_WINDOW", on_cancel)

            self.master.after(0, create_prompt_dialog)
            event.wait()
            
            final_prompt = result["prompt"]
            if not final_prompt:
                self.safe_log("å·²å–æ¶ˆç”Ÿæˆã€‚")
                return

            # === 3. ç”Ÿæˆåˆç¨¿ ===
            self.safe_log("æ­£åœ¨ç”Ÿæˆè‰ç¨¿æ­£æ–‡ï¼Œè¯·ç¨å€™...")
            draft_text = generate_chapter_draft(
                api_key=draft_key, base_url=draft_url, model_name=draft_model,
                filepath=filepath, novel_number=chap_num, word_number=word_num,
                temperature=draft_temp, user_guidance=user_guide,
                characters_involved=char_inv, key_items=key_items,
                scene_location=scene_loc, time_constraint=time_constr,
                embedding_api_key=emb_key, embedding_url=emb_url,
                embedding_interface_format=emb_fmt, embedding_model_name=emb_model,
                embedding_retrieval_k=emb_k, interface_format=draft_interface,
                max_tokens=draft_tokens, timeout=draft_timeout,
                custom_prompt_text=final_prompt
            )

            if not draft_text:
                self.safe_log("ç”Ÿæˆå¤±è´¥ï¼šè¿”å›å†…å®¹ä¸ºç©ºã€‚")
                return

            self.safe_log(f"âœ…æ¨¡å‹ï¼š{draft_model}, åˆç¨¿ç”Ÿæˆå®Œæ¯•ï¼Œæ­£åœ¨è¿›è¡Œé€»è¾‘è‡ªæ£€...")

            # === 4. è‡ªåŠ¨é€»è¾‘è‡ªæ£€ ===
            logic_report = analyze_chapter_logic(
                interface_format=review_interface,
                api_key=review_key,
                base_url=review_url,
                model_name=review_model,
                chapter_content=draft_text,
                filepath=filepath,
                novel_number=chap_num,
                timeout=draft_timeout
            )

            # === 5. å¼¹å‡ºâ€œé€»è¾‘è‡ªæ£€ä¸ä¿®è®¢â€çª—å£ (å«æ­£æ–‡å­—æ•°ç»Ÿè®¡) ===
            def show_logic_check_window():
                check_win = ctk.CTkToplevel(self.master)
                check_win.title(f"é€»è¾‘è‡ªæ£€ä¸ä¿®è®¢ - ç¬¬{chap_num}ç« ")
                check_win.geometry("1200x800")
                
                # å¸ƒå±€é…ç½®
                check_win.grid_columnconfigure(0, weight=3) # æ­£æ–‡åŒºåŸŸæ›´å®½
                check_win.grid_columnconfigure(1, weight=2)
                check_win.grid_rowconfigure(0, weight=1)
                
                # --- å·¦ä¾§ï¼šæ­£æ–‡ç¼–è¾‘åŒº ---
                left_frame = ctk.CTkFrame(check_win)
                left_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
                
                # å·¦ä¾§é¡¶éƒ¨æ ï¼ˆæ ‡é¢˜ + å­—æ•°ç»Ÿè®¡ï¼‰
                left_header = ctk.CTkFrame(left_frame, fg_color="transparent")
                left_header.pack(fill="x", pady=5, padx=5)
                ctk.CTkLabel(left_header, text="ç« èŠ‚æ­£æ–‡ (å¯æ‰‹åŠ¨ä¿®æ”¹)", font=("Microsoft YaHei", 14, "bold")).pack(side="left")
                content_wc_label = ctk.CTkLabel(left_header, text="å­—æ•°ï¼š0", font=("Microsoft YaHei", 12))
                content_wc_label.pack(side="right")

                content_box = ctk.CTkTextbox(left_frame, wrap="word", font=("Microsoft YaHei", 12))
                content_box.pack(fill="both", expand=True, padx=5, pady=5)
                content_box.insert("0.0", draft_text)
                
                # æ­£æ–‡å­—æ•°æ›´æ–°é€»è¾‘
                def update_content_wc(event=None):
                    text = content_box.get("0.0", "end-1c")
                    content_wc_label.configure(text=f"å­—æ•°ï¼š{len(text)}")
                
                content_box.bind("<KeyRelease>", update_content_wc)
                content_box.bind("<ButtonRelease>", update_content_wc)
                update_content_wc() # åˆå§‹åŒ–ç»Ÿè®¡

                # --- å³ä¾§ï¼šé€»è¾‘åé¦ˆåŒº ---
                right_frame = ctk.CTkFrame(check_win)
                right_frame.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
                ctk.CTkLabel(right_frame, text="é€»è¾‘æ¼æ´æŠ¥å‘Š (å¯ç¼–è¾‘åé¦ˆæ„è§)", font=("Microsoft YaHei", 14, "bold")).pack(pady=5)

                # è§£ææŠ¥å‘Šä¸­çš„ç‰¹å®šæ®µè½ï¼Œä¾¿äºå•ç‹¬æŸ¥çœ‹ä¸å¤åˆ¶
                def _parse_report_sections(text: str) -> dict:
                    sections = {
                        "knowledge_pov": "",
                        "future_conflict": "",
                        "full": text
                    }
                    try:
                        k_marker = "ã€çŸ¥è¯†ä¸ä¸€è‡´ & POV å¼‚å¸¸ã€‘"
                        f_marker = "ã€åæ–‡ç›®å½•å†²çªã€‘"
                        k_idx = text.find(k_marker)
                        f_idx = text.find(f_marker)
                        if k_idx != -1:
                            # ä» k_marker åˆ° f_marker æˆ– æ–‡æœ¬æœ«å°¾
                            start = k_idx + len(k_marker)
                            end = f_idx if (f_idx != -1 and f_idx > k_idx) else len(text)
                            sections["knowledge_pov"] = text[start:end].strip()
                        if f_idx != -1:
                            start = f_idx + len(f_marker)
                            sections["future_conflict"] = text[start:].strip()
                    except Exception:
                        pass
                    return sections

                parsed_sections = _parse_report_sections(logic_report if logic_report else "")

                # å¿«é€ŸæŸ¥çœ‹æŒ‰é’®
                btns_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
                btns_frame.pack(fill="x", padx=5, pady=(0, 4))

                def _open_section_popup(title: str, content: str):
                    popup = ctk.CTkToplevel(self.master)
                    popup.title(title)
                    popup.geometry("700x400")
                    txt = ctk.CTkTextbox(popup, wrap="word")
                    txt.pack(fill="both", expand=True, padx=8, pady=8)
                    txt.insert("0.0", content if content else "(æ— å†…å®¹)")

                    def _copy_to_feedback():
                        feedback_box.delete("0.0", "end")
                        feedback_box.insert("0.0", txt.get("0.0", "end").strip())
                        popup.destroy()

                    footer = ctk.CTkFrame(popup)
                    footer.pack(fill="x", padx=8, pady=6)
                    ctk.CTkButton(footer, text="å¤åˆ¶åˆ°åé¦ˆæ¡†", command=_copy_to_feedback, fg_color="#3498DB").pack(side="right", padx=6)
                    ctk.CTkButton(footer, text="å…³é—­", command=popup.destroy, fg_color="#95A5A6").pack(side="right")

                kb_btn = ctk.CTkButton(btns_frame, text="æŸ¥çœ‹ çŸ¥è¯†ä¸ä¸€è‡´ & POV", width=200, command=lambda: _open_section_popup("çŸ¥è¯†ä¸ä¸€è‡´ & POV å¼‚å¸¸", parsed_sections.get("knowledge_pov", "")))
                kb_btn.pack(side="right", padx=6)
                fc_btn = ctk.CTkButton(btns_frame, text="æŸ¥çœ‹ åæ–‡ç›®å½•å†²çª", width=200, command=lambda: _open_section_popup("åæ–‡ç›®å½•å†²çª", parsed_sections.get("future_conflict", "")))
                fc_btn.pack(side="right", padx=6)

                feedback_box = ctk.CTkTextbox(right_frame, wrap="word", font=("Microsoft YaHei", 12))
                feedback_box.pack(fill="both", expand=True, padx=5, pady=5)
                feedback_box.insert("0.0", logic_report)
                
                # --- åº•éƒ¨ï¼šæŒ‰é’®åŒº ---
                btn_frame = ctk.CTkFrame(check_win)
                btn_frame.grid(row=1, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
                
                status_lbl = ctk.CTkLabel(btn_frame, text="ç­‰å¾…æ“ä½œ...", text_color="gray")
                status_lbl.pack(side="left", padx=10)

                def _run_rewrite_with_model(use_interface, use_key, use_url, use_model, use_temp, use_tokens, use_timeout):
                    current_content = content_box.get("0.0", "end").strip()
                    current_feedback = feedback_box.get("0.0", "end").strip()
                    if not current_content:
                        return

                    status_lbl.configure(text=f"{use_model}â³ æ­£åœ¨æ ¹æ®åé¦ˆé‡å†™ï¼Œè¯·ç¨å€™...", text_color="blue")
                    logic_fix_btn.configure(state="disabled")
                    plot_refine_btn.configure(state="disabled")
                    confirm_btn.configure(state="disabled")

                    def run_rewrite():
                        try:
                            new_text = rewrite_chapter_with_feedback(
                                interface_format=use_interface,
                                api_key=use_key,
                                base_url=use_url,
                                model_name=use_model,
                                original_content=current_content,
                                feedback=current_feedback,
                                temperature=use_temp,
                                max_tokens=use_tokens,
                                timeout=use_timeout
                            )
                            if new_text:
                                self.master.after(0, lambda: content_box.delete("0.0", "end"))
                                self.master.after(0, lambda: content_box.insert("0.0", new_text))
                                self.master.after(0, lambda: feedback_box.delete("0.0", "end"))
                                self.master.after(0, lambda: feedback_box.insert("0.0", "ï¼ˆå·²æ ¹æ®æ„è§é‡å†™ã€‚è¯·æ£€æŸ¥å·¦ä¾§å†…å®¹ï¼Œå¦‚æœ‰æ–°é—®é¢˜å¯ç»§ç»­è¾“å…¥åé¦ˆã€‚ï¼‰"))
                                # é‡å†™å®Œæˆåæ›´æ–°å­—æ•°
                                self.master.after(0, update_content_wc)
                                self.master.after(0, lambda: status_lbl.configure(text="âœ… é‡å†™å®Œæˆ", text_color="green"))
                            else:
                                self.master.after(0, lambda: status_lbl.configure(text="âŒ é‡å†™å¤±è´¥", text_color="red"))
                        except Exception as e:
                            self.master.after(0, lambda: status_lbl.configure(text=f"âŒ å‡ºé”™: {str(e)}", text_color="red"))
                        finally:
                            self.master.after(0, lambda: logic_fix_btn.configure(state="normal"))
                            self.master.after(0, lambda: plot_refine_btn.configure(state="normal"))
                            self.master.after(0, lambda: confirm_btn.configure(state="normal"))

                    threading.Thread(target=run_rewrite, daemon=True).start()

                def on_rewrite_logic():
                    # ä½¿ç”¨é€»è¾‘/å®¡æ ¡æ¨¡å‹è¿›è¡Œä¿®æ­£ï¼ˆä¾§é‡é€»è¾‘ä¸€è‡´æ€§ï¼‰
                    _run_rewrite_with_model(
                        use_interface=review_interface,
                        use_key=review_key,
                        use_url=review_url,
                        use_model=review_model,
                        use_temp=review_temp if 'review_temp' in locals() else 0.3,
                        use_tokens=review_tokens if 'review_tokens' in locals() else draft_tokens,
                        use_timeout=draft_timeout
                    )

                def on_rewrite_plot():
                    # ä½¿ç”¨åˆç¨¿ç”Ÿæˆæ¨¡å‹è¿›è¡Œå‰§æƒ…å¾®è°ƒï¼ˆä¿æŒæ–‡é£ä¸æ‹“å±•ï¼‰
                    _run_rewrite_with_model(
                        use_interface=draft_interface,
                        use_key=draft_key,
                        use_url=draft_url,
                        use_model=draft_model,
                        use_temp=draft_temp,
                        use_tokens=draft_tokens,
                        use_timeout=draft_timeout
                    )

                def on_confirm():
                    final_content = content_box.get("0.0", "end").strip()
                    
                    # ä¿å­˜åˆ°æ–‡ä»¶
                    chapters_dir = os.path.join(filepath, "chapters")
                    os.makedirs(chapters_dir, exist_ok=True)
                    chapter_file = os.path.join(chapters_dir, f"chapter_{chap_num}.txt")
                    
                    clear_file_content(chapter_file)
                    save_string_to_txt(final_content, chapter_file)
                    
                    # æ›´æ–°ä¸»ç•Œé¢æ˜¾ç¤º
                    self.show_chapter_in_textbox(final_content)
                    self.safe_log(f"âœ… ç¬¬{chap_num}ç« å·²ç¡®è®¤å¹¶ä¿å­˜ã€‚")
                    check_win.destroy()

                logic_fix_btn = ctk.CTkButton(btn_frame, text="é€»è¾‘çº æ­£ (Logic Fix)", command=on_rewrite_logic, fg_color="#E67E22", width=180)
                logic_fix_btn.pack(side="right", padx=6)

                plot_refine_btn = ctk.CTkButton(btn_frame, text="å‰§æƒ…å¾®è°ƒ (Plot Refine)", command=on_rewrite_plot, fg_color="#8E44AD", width=180)
                plot_refine_btn.pack(side="right", padx=6)
                
                confirm_btn = ctk.CTkButton(btn_frame, text="ç¡®è®¤æ— è¯¯ï¼Œä½¿ç”¨æ­¤ç‰ˆæœ¬ (Confirm)", command=on_confirm, fg_color="#27AE60", width=200)
                confirm_btn.pack(side="right", padx=10)
                
                check_win.protocol("WM_DELETE_WINDOW", on_confirm)

            self.master.after(0, show_logic_check_window)

        except Exception as e:
            self.handle_exception("ç”Ÿæˆè‰ç¨¿æµç¨‹å‡ºé”™")
        finally:
            self.enable_button_safe(self.btn_generate_chapter)

    threading.Thread(target=task, daemon=True).start()

def finalize_chapter_ui(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return

    def task():
        if not messagebox.askyesno("ç¡®è®¤", "ç¡®å®šè¦å®šç¨¿å½“å‰ç« èŠ‚å—ï¼Ÿ"):
            self.enable_button_safe(self.btn_finalize_chapter)
            return

        self.disable_button_safe(self.btn_finalize_chapter)
        try:

            interface_format = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["interface_format"]
            api_key = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["api_key"]
            base_url = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["base_url"]
            model_name = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["model_name"]
            temperature = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["temperature"]
            max_tokens = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["max_tokens"]
            timeout_val = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["timeout"]


            embedding_api_key = self.embedding_api_key_var.get().strip()
            embedding_url = self.embedding_url_var.get().strip()
            embedding_interface_format = self.embedding_interface_format_var.get().strip()
            embedding_model_name = self.embedding_model_name_var.get().strip()

            chap_num = self.safe_get_int(self.chapter_num_var, 1)
            word_number = self.safe_get_int(self.word_number_var, 3000)

            self.safe_log(f"å¼€å§‹å®šç¨¿ç¬¬{chap_num}ç« ...")

            chapters_dir = os.path.join(filepath, "chapters")
            os.makedirs(chapters_dir, exist_ok=True)
            chapter_file = os.path.join(chapters_dir, f"chapter_{chap_num}.txt")

            edited_text = self.chapter_result.get("0.0", "end").strip()

            if len(edited_text) < 0.7 * word_number:
                ask = messagebox.askyesno("å­—æ•°ä¸è¶³", f"å½“å‰ç« èŠ‚å­—æ•° ({len(edited_text)}) ä½äºç›®æ ‡å­—æ•°({word_number})çš„70%ï¼Œæ˜¯å¦è¦å°è¯•æ‰©å†™ï¼Ÿ")
                if ask:
                    self.safe_log("æ­£åœ¨æ‰©å†™ç« èŠ‚å†…å®¹...")
                    enriched = enrich_chapter_text(
                        chapter_text=edited_text,
                        word_number=word_number,
                        api_key=api_key,
                        base_url=base_url,
                        model_name=model_name,
                        temperature=temperature,
                        interface_format=interface_format,
                        max_tokens=max_tokens,
                        timeout=timeout_val
                    )
                    edited_text = enriched
                    self.master.after(0, lambda: self.chapter_result.delete("0.0", "end"))
                    self.master.after(0, lambda: self.chapter_result.insert("0.0", edited_text))
            clear_file_content(chapter_file)
            save_string_to_txt(edited_text, chapter_file)

            finalize_chapter(
                novel_number=chap_num,
                word_number=word_number,
                api_key=api_key,
                base_url=base_url,
                model_name=model_name,
                temperature=temperature,
                filepath=filepath,
                embedding_api_key=embedding_api_key,
                embedding_url=embedding_url,
                embedding_interface_format=embedding_interface_format,
                embedding_model_name=embedding_model_name,
                interface_format=interface_format,
                max_tokens=max_tokens,
                timeout=timeout_val
            )
            self.safe_log(f"âœ… ç¬¬{chap_num}ç« å®šç¨¿å®Œæˆï¼ˆå·²æ›´æ–°å‰æ–‡æ‘˜è¦ã€è§’è‰²çŠ¶æ€ã€å‘é‡åº“ï¼‰ã€‚")

            final_text = read_file(chapter_file)
            self.master.after(0, lambda: self.show_chapter_in_textbox(final_text))
        except Exception:
            self.handle_exception("å®šç¨¿ç« èŠ‚æ—¶å‡ºé”™")
        finally:
            self.enable_button_safe(self.btn_finalize_chapter)
    threading.Thread(target=task, daemon=True).start()

def do_consistency_check(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return

    def task():
        self.disable_button_safe(self.btn_check_consistency)
        try:
            interface_format = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["interface_format"]
            api_key = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["api_key"]
            base_url = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["base_url"]
            model_name = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["model_name"]
            temperature = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["temperature"]
            max_tokens = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["max_tokens"]
            timeout = self.loaded_config["llm_configs"][self.consistency_review_llm_var.get()]["timeout"]


            chap_num = self.safe_get_int(self.chapter_num_var, 1)
            chap_file = os.path.join(filepath, "chapters", f"chapter_{chap_num}.txt")
            chapter_text = read_file(chap_file)

            if not chapter_text.strip():
                self.safe_log("âš ï¸ å½“å‰ç« èŠ‚æ–‡ä»¶ä¸ºç©ºæˆ–ä¸å­˜åœ¨ï¼Œæ— æ³•å®¡æ ¡ã€‚")
                return

            self.safe_log("å¼€å§‹ä¸€è‡´æ€§å®¡æ ¡...")
            result = check_consistency(
                novel_setting="",
                character_state=read_file(os.path.join(filepath, "character_state.txt")),
                global_summary=read_file(os.path.join(filepath, "global_summary.txt")),
                chapter_text=chapter_text,
                api_key=api_key,
                base_url=base_url,
                model_name=model_name,
                temperature=temperature,
                interface_format=interface_format,
                max_tokens=max_tokens,
                timeout=timeout,
                plot_arcs=""
            )
            self.safe_log("å®¡æ ¡ç»“æœï¼š")
            self.safe_log(result)
        except Exception:
            self.handle_exception("å®¡æ ¡æ—¶å‡ºé”™")
        finally:
            self.enable_button_safe(self.btn_check_consistency)
    threading.Thread(target=task, daemon=True).start()
def generate_batch_ui(self):

    # PenBo ä¼˜åŒ–ç•Œé¢ï¼Œä½¿ç”¨customtkinterè¿›è¡Œæ‰¹é‡ç”Ÿæˆç« èŠ‚ç•Œé¢
    def open_batch_dialog():
        dialog = ctk.CTkToplevel()
        dialog.title("æ‰¹é‡ç”Ÿæˆç« èŠ‚")
        
        chapter_file = os.path.join(self.filepath_var.get().strip(), "chapters")
        files = glob.glob(os.path.join(chapter_file, "chapter_*.txt"))
        if not files:
            num = 1
        else:
            num = max(int(os.path.basename(f).split('_')[1].split('.')[0]) for f in files) + 1
            
        dialog.geometry("400x200")
        dialog.resizable(False, False)
        
        # åˆ›å»ºç½‘æ ¼å¸ƒå±€
        dialog.grid_columnconfigure(0, weight=0)
        dialog.grid_columnconfigure(1, weight=1)
        dialog.grid_columnconfigure(2, weight=0)
        dialog.grid_columnconfigure(3, weight=1)
        
        # èµ·å§‹ç« èŠ‚
        ctk.CTkLabel(dialog, text="èµ·å§‹ç« èŠ‚:").grid(row=0, column=0, padx=10, pady=10, sticky="w")
        entry_start = ctk.CTkEntry(dialog)
        entry_start.grid(row=0, column=1, padx=10, pady=10, sticky="ew")
        entry_start.insert(0, str(num))
        
        # ç»“æŸç« èŠ‚
        ctk.CTkLabel(dialog, text="ç»“æŸç« èŠ‚:").grid(row=0, column=2, padx=10, pady=10, sticky="w")
        entry_end = ctk.CTkEntry(dialog)
        entry_end.grid(row=0, column=3, padx=10, pady=10, sticky="ew")
        
        # æœŸæœ›å­—æ•°
        ctk.CTkLabel(dialog, text="æœŸæœ›å­—æ•°:").grid(row=1, column=0, padx=10, pady=10, sticky="w")
        entry_word = ctk.CTkEntry(dialog)
        entry_word.grid(row=1, column=1, padx=10, pady=10, sticky="ew")
        entry_word.insert(0, self.word_number_var.get())
        
        # æœ€ä½å­—æ•°
        ctk.CTkLabel(dialog, text="æœ€ä½å­—æ•°:").grid(row=1, column=2, padx=10, pady=10, sticky="w")
        entry_min = ctk.CTkEntry(dialog)
        entry_min.grid(row=1, column=3, padx=10, pady=10, sticky="ew")
        entry_min.insert(0, self.word_number_var.get())

        # è‡ªåŠ¨æ‰©å†™é€‰é¡¹
        auto_enrich_bool = ctk.BooleanVar()
        auto_enrich_bool_ck = ctk.CTkCheckBox(dialog, text="ä½äºæœ€ä½å­—æ•°æ—¶è‡ªåŠ¨æ‰©å†™", variable=auto_enrich_bool)
        auto_enrich_bool_ck.grid(row=2, column=0, columnspan=2, padx=10, pady=10, sticky="w")

        result = {"start": None, "end": None, "word": None, "min": None, "auto_enrich": None, "close": False}

        def on_confirm():
            nonlocal result
            if not entry_start.get() or not entry_end.get() or not entry_word.get() or not entry_min.get():
                messagebox.showwarning("è­¦å‘Š", "è¯·å¡«å†™å®Œæ•´ä¿¡æ¯ã€‚")
                return

            result = {
                "start": entry_start.get(),
                "end": entry_end.get(),
                "word": entry_word.get(),
                "min": entry_min.get(),
                "auto_enrich": auto_enrich_bool.get(),
                "close": False
            }
            dialog.destroy()

        def on_cancel():
            nonlocal result
            result["close"] = True
            dialog.destroy()
            
        # æŒ‰é’®æ¡†æ¶
        button_frame = ctk.CTkFrame(dialog)
        button_frame.grid(row=3, column=0, columnspan=4, padx=10, pady=10, sticky="ew")
        button_frame.grid_columnconfigure(0, weight=1)
        button_frame.grid_columnconfigure(1, weight=1)
        
        ctk.CTkButton(button_frame, text="ç¡®è®¤", command=on_confirm).grid(row=0, column=0, padx=10, pady=10, sticky="e")
        ctk.CTkButton(button_frame, text="å–æ¶ˆ", command=on_cancel).grid(row=0, column=1, padx=10, pady=10, sticky="w")
        
        dialog.protocol("WM_DELETE_WINDOW", on_cancel)
        dialog.transient(self.master)
        dialog.wait_window(dialog)
        return result
    
    def generate_chapter_batch(self ,i ,word, min, auto_enrich):
        draft_interface_format = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["interface_format"]
        draft_api_key = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["api_key"]
        draft_base_url = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["base_url"]
        draft_model_name = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["model_name"]
        draft_temperature = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["temperature"]
        draft_max_tokens = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["max_tokens"]
        draft_timeout = self.loaded_config["llm_configs"][self.prompt_draft_llm_var.get()]["timeout"]
        user_guidance = self.user_guide_text.get("0.0", "end").strip()  

        char_inv = self.characters_involved_var.get().strip()
        key_items = self.key_items_var.get().strip()
        scene_loc = self.scene_location_var.get().strip()
        time_constr = self.time_constraint_var.get().strip()

        embedding_api_key = self.embedding_api_key_var.get().strip()
        embedding_url = self.embedding_url_var.get().strip()
        embedding_interface_format = self.embedding_interface_format_var.get().strip()
        embedding_model_name = self.embedding_model_name_var.get().strip()
        embedding_k = self.safe_get_int(self.embedding_retrieval_k_var, 4)

        prompt_text = build_chapter_prompt(
            api_key=draft_api_key,
            base_url=draft_base_url,
            model_name=draft_model_name,
            filepath=self.filepath_var.get().strip(),
            novel_number=i,
            word_number=word,
            temperature=draft_temperature,
            user_guidance=user_guidance,
            characters_involved=char_inv,
            key_items=key_items,
            scene_location=scene_loc,
            time_constraint=time_constr,
            embedding_api_key=embedding_api_key,
            embedding_url=embedding_url,
            embedding_interface_format=embedding_interface_format,
            embedding_model_name=embedding_model_name,
            embedding_retrieval_k=embedding_k,
            interface_format=draft_interface_format,
            max_tokens=draft_max_tokens,
            timeout=draft_timeout,
        )
        final_prompt = prompt_text
        role_names = [name.strip() for name in self.char_inv_text.get("0.0", "end").split("\n")]
        role_lib_path = os.path.join(self.filepath_var.get().strip(), "è§’è‰²åº“")
        role_contents = []
        if os.path.exists(role_lib_path):
            for root, dirs, files in os.walk(role_lib_path):
                for file in files:
                    if file.endswith(".txt") and os.path.splitext(file)[0] in role_names:
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                role_contents.append(f.read().strip())  # ç›´æ¥ä½¿ç”¨æ–‡ä»¶å†…å®¹ï¼Œä¸æ·»åŠ é‡å¤åå­—
                        except Exception as e:
                            self.safe_log(f"è¯»å–è§’è‰²æ–‡ä»¶ {file} å¤±è´¥: {str(e)}")
        if role_contents:
            role_content_str = "\n".join(role_contents)
            # æ›´ç²¾ç¡®çš„æ›¿æ¢é€»è¾‘ï¼Œå¤„ç†ä¸åŒæƒ…å†µä¸‹çš„å ä½ç¬¦
            placeholder_variations = [
                "æ ¸å¿ƒäººç‰©(å¯èƒ½æœªæŒ‡å®š)ï¼š{characters_involved}",
                "æ ¸å¿ƒäººç‰©ï¼š{characters_involved}",
                "æ ¸å¿ƒäººç‰©(å¯èƒ½æœªæŒ‡å®š):{characters_involved}",
                "æ ¸å¿ƒäººç‰©:{characters_involved}"
            ]
            
            for placeholder in placeholder_variations:
                if placeholder in final_prompt:
                    final_prompt = final_prompt.replace(
                        placeholder,
                        f"æ ¸å¿ƒäººç‰©ï¼š\n{role_content_str}"
                    )
                    break
            else:  # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å·²çŸ¥å ä½ç¬¦å˜ä½“
                lines = final_prompt.split('\n')
                for i, line in enumerate(lines):
                    if "æ ¸å¿ƒäººç‰©" in line and "ï¼š" in line:
                        lines[i] = f"æ ¸å¿ƒäººç‰©ï¼š\n{role_content_str}"
                        break
                final_prompt = '\n'.join(lines)
        draft_text = generate_chapter_draft(
            api_key=draft_api_key,
            base_url=draft_base_url,
            model_name=draft_model_name,
            filepath=self.filepath_var.get().strip(),
            novel_number=i,
            word_number=word,
            temperature=draft_temperature,
            user_guidance=user_guidance,
            characters_involved=char_inv,
            key_items=key_items,
            scene_location=scene_loc,
            time_constraint=time_constr,
            embedding_api_key=embedding_api_key,
            embedding_url=embedding_url,
            embedding_interface_format=embedding_interface_format,
            embedding_model_name=embedding_model_name,
            embedding_retrieval_k=embedding_k,
            interface_format=draft_interface_format,
            max_tokens=draft_max_tokens,
            timeout=draft_timeout,
            custom_prompt_text=final_prompt  
        )

        finalize_interface_format = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["interface_format"]
        finalize_api_key = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["api_key"]
        finalize_base_url = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["base_url"]
        finalize_model_name = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["model_name"]
        finalize_temperature = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["temperature"]
        finalize_max_tokens = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["max_tokens"]
        finalize_timeout = self.loaded_config["llm_configs"][self.final_chapter_llm_var.get()]["timeout"]

        chapters_dir = os.path.join(self.filepath_var.get().strip(), "chapters")
        os.makedirs(chapters_dir, exist_ok=True)
        chapter_path = os.path.join(chapters_dir, f"chapter_{i}.txt")
        if len(draft_text) < 0.7 * min and auto_enrich:
            self.safe_log(f"ç¬¬{i}ç« è‰ç¨¿å­—æ•° ({len(draft_text)}) ä½äºç›®æ ‡å­—æ•°({min})çš„70%ï¼Œæ­£åœ¨æ‰©å†™...")
            enriched = enrich_chapter_text(
                chapter_text=draft_text,
                word_number=word,
                api_key=draft_api_key,
                base_url=draft_base_url,
                model_name=draft_model_name,
                temperature=draft_temperature,
                interface_format=draft_interface_format,
                max_tokens=draft_max_tokens,
                timeout=draft_timeout
            )
            draft_text = enriched
        clear_file_content(chapter_path)
        save_string_to_txt(draft_text, chapter_path)
        finalize_chapter(
            novel_number=i,
            word_number=word,
            api_key=finalize_api_key,
            base_url=finalize_base_url,
            model_name=finalize_model_name,
            temperature=finalize_temperature,
            filepath=self.filepath_var.get().strip(),
            embedding_api_key=embedding_api_key,
            embedding_url=embedding_url,
            embedding_interface_format=embedding_interface_format,
            embedding_model_name=embedding_model_name,
            interface_format=finalize_interface_format,
            max_tokens=finalize_max_tokens,
            timeout=finalize_timeout
        )


    result = open_batch_dialog()
    if result["close"]:
        return

    for i in range(int(result["start"]), int(result["end"]) + 1):
        generate_chapter_batch(self, i, int(result["word"]), int(result["min"]), result["auto_enrich"])


def import_knowledge_handler(self):
    selected_file = filedialog.askopenfilename(
        title="é€‰æ‹©è¦å¯¼å…¥çš„çŸ¥è¯†åº“æ–‡ä»¶",
        filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
    )
    if selected_file:
        def task():
            self.disable_button_safe(self.btn_import_knowledge)
            try:
                emb_api_key = self.embedding_api_key_var.get().strip()
                emb_url = self.embedding_url_var.get().strip()
                emb_format = self.embedding_interface_format_var.get().strip()
                emb_model = self.embedding_model_name_var.get().strip()

                # å°è¯•ä¸åŒç¼–ç è¯»å–æ–‡ä»¶
                content = None
                encodings = ['utf-8', 'gbk', 'gb2312', 'ansi']
                for encoding in encodings:
                    try:
                        with open(selected_file, 'r', encoding=encoding) as f:
                            content = f.read()
                            break
                    except UnicodeDecodeError:
                        continue
                    except Exception as e:
                        self.safe_log(f"è¯»å–æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
                        raise

                if content is None:
                    raise Exception("æ— æ³•ä»¥ä»»ä½•å·²çŸ¥ç¼–ç æ ¼å¼è¯»å–æ–‡ä»¶")

                # åˆ›å»ºä¸´æ—¶UTF-8æ–‡ä»¶
                import tempfile
                import os
                with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', delete=False, suffix='.txt') as temp:
                    temp.write(content)
                    temp_path = temp.name

                try:
                    self.safe_log(f"å¼€å§‹å¯¼å…¥çŸ¥è¯†åº“æ–‡ä»¶: {selected_file}")
                    import_knowledge_file(
                        embedding_api_key=emb_api_key,
                        embedding_url=emb_url,
                        embedding_interface_format=emb_format,
                        embedding_model_name=emb_model,
                        file_path=temp_path,
                        filepath=self.filepath_var.get().strip()
                    )
                    self.safe_log("âœ… çŸ¥è¯†åº“æ–‡ä»¶å¯¼å…¥å®Œæˆã€‚")
                finally:
                    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                    try:
                        os.unlink(temp_path)
                    except:
                        pass

            except Exception:
                self.handle_exception("å¯¼å…¥çŸ¥è¯†åº“æ—¶å‡ºé”™")
            finally:
                self.enable_button_safe(self.btn_import_knowledge)

        try:
            thread = threading.Thread(target=task, daemon=True)
            thread.start()
        except Exception as e:
            self.enable_button_safe(self.btn_import_knowledge)
            messagebox.showerror("é”™è¯¯", f"çº¿ç¨‹å¯åŠ¨å¤±è´¥: {str(e)}")

def clear_vectorstore_handler(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return

    first_confirm = messagebox.askyesno("è­¦å‘Š", "ç¡®å®šè¦æ¸…ç©ºæœ¬åœ°å‘é‡åº“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼")
    if first_confirm:
        second_confirm = messagebox.askyesno("äºŒæ¬¡ç¡®è®¤", "ä½ ç¡®å®šçœŸçš„è¦åˆ é™¤æ‰€æœ‰å‘é‡æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼")
        if second_confirm:
            if clear_vector_store(filepath):
                self.log("å·²æ¸…ç©ºå‘é‡åº“ã€‚")
            else:
                self.log(f"æœªèƒ½æ¸…ç©ºå‘é‡åº“ï¼Œè¯·å…³é—­ç¨‹åºåæ‰‹åŠ¨åˆ é™¤ {filepath} ä¸‹çš„ vectorstore æ–‡ä»¶å¤¹ã€‚")

def show_plot_arcs_ui(self):
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœ¨ä¸»Tabä¸­è®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return

    plot_arcs_file = os.path.join(filepath, "plot_arcs.txt")
    if not os.path.exists(plot_arcs_file):
        messagebox.showinfo("å‰§æƒ…è¦ç‚¹", "å½“å‰è¿˜æœªç”Ÿæˆä»»ä½•å‰§æƒ…è¦ç‚¹æˆ–å†²çªè®°å½•ã€‚")
        return

    arcs_text = read_file(plot_arcs_file).strip()
    if not arcs_text:
        arcs_text = "å½“å‰æ²¡æœ‰è®°å½•çš„å‰§æƒ…è¦ç‚¹æˆ–å†²çªã€‚"

    top = ctk.CTkToplevel(self.master)
    top.title("å‰§æƒ…è¦ç‚¹/æœªè§£å†³å†²çª")
    top.geometry("600x400")
    text_area = ctk.CTkTextbox(top, wrap="word", font=("Microsoft YaHei", 12))
    text_area.pack(fill="both", expand=True, padx=10, pady=10)
    text_area.insert("0.0", arcs_text)
    text_area.configure(state="disabled")


def refine_directory_card_ui(self):
    """
    å¾®è°ƒç« èŠ‚ç›®å½•çš„äº¤äº’ç•Œé¢ (æ”¯æŒå¤šç« èŠ‚èŒƒå›´ä¿®æ”¹)
    """
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆé…ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„ã€‚")
        return
        
    directory_file = os.path.join(filepath, "Novel_directory.txt")
    if not os.path.exists(directory_file):
        messagebox.showwarning("è­¦å‘Š", "å°šæœªç”Ÿæˆç›®å½•æ–‡ä»¶ (Novel_directory.txt)ã€‚")
        return

    # åˆ›å»ºå¼¹çª—
    dialog = ctk.CTkToplevel(self.master)
    dialog.title("å¾®è°ƒç« èŠ‚å¤§çº² (æ”¯æŒå¤šç« èŠ‚)")
    dialog.geometry("1000x750")
    
    # å¸ƒå±€é…ç½®
    dialog.grid_columnconfigure(0, weight=1)
    dialog.grid_rowconfigure(1, weight=1)

    # --- é¡¶éƒ¨æ§åˆ¶åŒº ---
    top_frame = ctk.CTkFrame(dialog)
    top_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=10)
    
    ctk.CTkLabel(top_frame, text="èµ·å§‹ç« èŠ‚:").pack(side="left", padx=(10, 5))
    start_chap_entry = ctk.CTkEntry(top_frame, width=60)
    start_chap_entry.pack(side="left", padx=5)
    
    ctk.CTkLabel(top_frame, text="ç»“æŸç« èŠ‚:").pack(side="left", padx=(15, 5))
    end_chap_entry = ctk.CTkEntry(top_frame, width=60)
    end_chap_entry.pack(side="left", padx=5)
    
    # è¾…åŠ©å‡½æ•°ï¼šæ„é€ æ­£åˆ™
    def get_range_pattern(start_num, end_num):
        # åŒ¹é…ä» "ç¬¬{start}ç« " å¼€å§‹ï¼Œä¸€ç›´åˆ° "ç¬¬{end+1}ç« " ä¹‹å‰ï¼ˆæˆ–æ–‡ä»¶æœ«å°¾ï¼‰çš„æ‰€æœ‰å†…å®¹
        # å…¼å®¹ "ç« èŠ‚ç¼–å·ï¼šç¬¬Xç« " å’Œ "ç¬¬Xç« " ä¸¤ç§æ ¼å¼
        # è¿™é‡Œçš„é€»è¾‘æ˜¯ï¼šæ‰¾åˆ° Start çš„å¼€å¤´ï¼Œç„¶åå‘åæ‰¾ï¼Œç›´åˆ°æ‰¾åˆ° (End+1) çš„å¼€å¤´
        next_num = end_num + 1
        pattern_str = (
            f"(?:(?:ç« èŠ‚ç¼–å·ï¼š\\s*)?ç¬¬\\s*{start_num}\\s*ç« )"  # èµ·å§‹æ ‡è®°
            f".*?"                                          # ä¸­é—´å†…å®¹ (éè´ªå©ª)
            f"(?=(?:\\n\\s*(?:ç« èŠ‚ç¼–å·ï¼š\\s*)?ç¬¬\\s*{next_num}\\s*ç« )|\\Z)" # ç»“æŸæ ‡è®° (å‰ç»æ–­è¨€ï¼šæ˜¯ä¸‹ä¸€ç« å¼€å¤´ æˆ– æ–‡ä»¶æœ«å°¾)
        )
        return re.compile(pattern_str, re.DOTALL)

    def load_chapter_info():
        s_val = start_chap_entry.get().strip()
        e_val = end_chap_entry.get().strip()
        
        if not s_val:
            messagebox.showwarning("æç¤º", "è¯·è¾“å…¥èµ·å§‹ç« èŠ‚å·")
            return
        
        try:
            start_num = int(s_val)
            # å¦‚æœæ²¡å¡«ç»“æŸç« èŠ‚ï¼Œé»˜è®¤ç­‰äºèµ·å§‹ç« èŠ‚ï¼ˆå•ç« æ¨¡å¼ï¼‰
            end_num = int(e_val) if e_val else start_num
            
            if end_num < start_num:
                messagebox.showerror("é”™è¯¯", "ç»“æŸç« èŠ‚ä¸èƒ½å°äºèµ·å§‹ç« èŠ‚")
                return

            content = read_file(directory_file)
            pattern = get_range_pattern(start_num, end_num)
            
            match = pattern.search(content)
            if match:
                extracted = match.group(0).strip()
                outline_text.delete("0.0", "end")
                outline_text.insert("0.0", extracted)
                status_label.configure(text=f"å·²åŠ è½½: ç¬¬ {start_num} - {end_num} ç« ", text_color="green")
                return True
            else:
                status_label.configure(text=f"æœªæ‰¾åˆ°ç« èŠ‚èŒƒå›´ {start_num}-{end_num}ï¼Œè¯·æ£€æŸ¥ç›®å½•æ–‡ä»¶ã€‚", text_color="red")
                return False
                
        except ValueError:
            messagebox.showerror("é”™è¯¯", "ç« èŠ‚å·å¿…é¡»æ˜¯æ•°å­—")
        except Exception as e:
            messagebox.showerror("é”™è¯¯", f"è¯»å–å¤±è´¥: {str(e)}")
            return False

    ctk.CTkButton(top_frame, text="è¯»å–èŒƒå›´å¤§çº²", command=load_chapter_info, width=120).pack(side="left", padx=15)
    status_label = ctk.CTkLabel(top_frame, text="å‡†å¤‡å°±ç»ª", text_color="gray")
    status_label.pack(side="left", padx=10)

    # --- ä¸­é—´å†…å®¹åŒº ---
    content_frame = ctk.CTkFrame(dialog)
    content_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=5)
    content_frame.grid_columnconfigure(0, weight=1)
    content_frame.grid_rowconfigure(1, weight=1)
    
    ctk.CTkLabel(content_frame, text="å¤§çº²å†…å®¹ (å¯ç¼–è¾‘/AIç”Ÿæˆ)", font=("Microsoft YaHei", 12, "bold")).grid(row=0, column=0, sticky="w", pady=5)
    outline_text = ctk.CTkTextbox(content_frame, wrap="word", font=("Microsoft YaHei", 12))
    outline_text.grid(row=1, column=0, sticky="nsew", padx=5)
    
    # --- åº•éƒ¨æŒ‡ä»¤åŒº ---
    bottom_frame = ctk.CTkFrame(dialog)
    bottom_frame.grid(row=2, column=0, sticky="ew", padx=10, pady=10)
    
    ctk.CTkLabel(bottom_frame, text="ä¿®æ”¹æ„è§ (ä¾‹å¦‚ï¼š'è®©ç¬¬5ç« çš„æˆ˜æ–—æ›´æƒ¨çƒˆï¼Œå¹¶åœ¨ç¬¬6ç« å¼€å¤´å¢åŠ ä¸»è§’çš„æ„Ÿæ‚Ÿ'):", font=("Microsoft YaHei", 12, "bold")).pack(anchor="w", padx=5)
    instruction_text = ctk.CTkTextbox(bottom_frame, height=80, wrap="word")
    instruction_text.pack(fill="x", padx=5, pady=5)
    
    btn_area = ctk.CTkFrame(bottom_frame, fg_color="transparent")
    btn_area.pack(fill="x", pady=5)

    def on_ai_refine():
        current_content = outline_text.get("0.0", "end").strip()
        instruction = instruction_text.get("0.0", "end").strip()
        s_val = start_chap_entry.get().strip()
        e_val = end_chap_entry.get().strip() or s_val
        
        if not s_val:
            messagebox.showwarning("æç¤º", "è¯·ç¡®ä¿å·²å¡«å†™ç« èŠ‚å·ã€‚")
            return
        if not current_content:
            messagebox.showwarning("æç¤º", "è¯·å…ˆè¯»å–ç« èŠ‚å¤§çº²å†…å®¹ã€‚")
            return
        if not instruction:
            messagebox.showwarning("æç¤º", "è¯·è¾“å…¥ä¿®æ”¹æ„è§ã€‚")
            return
            
        # è¯»å–èƒŒæ™¯
        arch_file = os.path.join(filepath, "Novel_architecture.txt")
        summary_file = os.path.join(filepath, "global_summary.txt")
        novel_arch_content = read_file(arch_file) if os.path.exists(arch_file) else ""
        global_sum_content = read_file(summary_file) if os.path.exists(summary_file) else ""

        # è·å–é…ç½®
        try:
            llm_var = self.refine_logic_llm_var.get()
            config = self.loaded_config["llm_configs"][llm_var]
        except:
            messagebox.showerror("é”™è¯¯", "æ— æ³•è·å–é…ç½®ã€‚")
            return

        status_label.configure(text="AI æ­£åœ¨æ€è€ƒå¹¶å¾®è°ƒå‰§æƒ…...", text_color="blue")
        refine_btn.configure(state="disabled")
        
        def run_task():
            try:
                chapter_range_str = f"ç¬¬{s_val}ç« " if s_val == e_val else f"ç¬¬{s_val}ç«  åˆ° ç¬¬{e_val}ç« "
                
                new_outline = refine_chapter_detail(
                    interface_format=config["interface_format"],
                    api_key=config["api_key"],
                    base_url=config["base_url"],
                    model_name=config["model_name"],
                    chapter_range=chapter_range_str, # ä¼ å…¥èŒƒå›´æè¿°
                    novel_architecture=novel_arch_content,
                    global_summary=global_sum_content,
                    current_outline=current_content,
                    user_instruction=instruction,
                    temperature=config["temperature"],
                    max_tokens=config["max_tokens"],
                    timeout=config["timeout"]
                )
                
                if new_outline:
                    self.master.after(0, lambda: outline_text.delete("0.0", "end"))
                    self.master.after(0, lambda: outline_text.insert("0.0", new_outline))
                    self.master.after(0, lambda: status_label.configure(text="âœ… å¾®è°ƒå®Œæˆï¼Œè¯·æ£€æŸ¥", text_color="green"))
                else:
                    self.master.after(0, lambda: status_label.configure(text="âŒ å¾®è°ƒå¤±è´¥ (è¿”å›ç©º)", text_color="red"))
            except Exception as e:
                self.master.after(0, lambda: status_label.configure(text=f"âŒ å‡ºé”™: {str(e)}", text_color="red"))
            finally:
                self.master.after(0, lambda: refine_btn.configure(state="normal"))

        threading.Thread(target=run_task, daemon=True).start()

    def on_save_confirm():
        try:
            s_val = start_chap_entry.get().strip()
            e_val = end_chap_entry.get().strip()
            
            if not s_val:
                messagebox.showwarning("æç¤º", "è¯·è¾“å…¥èµ·å§‹ç« èŠ‚å·ä»¥å®šä½æ›¿æ¢ä½ç½®ã€‚")
                return
                
            start_num = int(s_val)
            end_num = int(e_val) if e_val else start_num
            
            new_block = outline_text.get("0.0", "end").strip()
            if not new_block:
                messagebox.showwarning("æç¤º", "å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ä¿å­˜ã€‚")
                return

            # è¯»å–å…¨æ–‡
            full_content = read_file(directory_file)
            
            # ä½¿ç”¨ç›¸åŒçš„æ­£åˆ™é€»è¾‘å®šä½åŸæ–‡ä½ç½®
            pattern = get_range_pattern(start_num, end_num)
            match = pattern.search(full_content)
            
            if match:
                # æ‰§è¡Œæ›¿æ¢
                # pattern.sub(new, old, count=1) ä¼šæ›¿æ¢æ‰åŒ¹é…åˆ°çš„é‚£ä¸€æ®µ
                updated_full_content = pattern.sub(new_block, full_content, count=1)
                
                # ä¿å­˜
                save_string_to_txt(updated_full_content, directory_file)
                
                # æ›´æ–°ä¸»ç•Œé¢
                if hasattr(self, 'directory_text'):
                    self.directory_text.delete("0.0", "end")
                    self.directory_text.insert("0.0", updated_full_content)
                
                messagebox.showinfo("æˆåŠŸ", f"ç¬¬ {start_num}-{end_num} ç« å¤§çº²å·²æ›´æ–°å¹¶ä¿å­˜ã€‚")
                dialog.destroy()
            else:
                messagebox.showerror("å®šä½å¤±è´¥", 
                    f"åœ¨åŸæ–‡ä»¶ä¸­æœªæ‰¾åˆ°ç¬¬ {start_num}-{end_num} ç« çš„è¿ç»­å—ã€‚\n"
                    "å¯èƒ½åŸå› ï¼š\n1. ç« èŠ‚å·ä¸è¿ç»­\n2. æ ¼å¼è¢«ç ´å\n3. æ–‡ä»¶å·²è¢«å¤–éƒ¨ä¿®æ”¹\n"
                    "å»ºè®®ï¼šæ‰‹åŠ¨å¤åˆ¶å†…å®¹åˆ°ä¸»ç•Œé¢è¿›è¡Œç²˜è´´ã€‚"
                )
                
        except ValueError:
            messagebox.showerror("é”™è¯¯", "ç« èŠ‚å·æ ¼å¼é”™è¯¯ã€‚")
        except Exception as e:
            messagebox.showerror("ä¿å­˜å¼‚å¸¸", str(e))

    refine_btn = ctk.CTkButton(btn_area, text="âœ¨ AI æ™ºèƒ½å¾®è°ƒ", command=on_ai_refine, fg_color="#E67E22", width=150)
    refine_btn.pack(side="left", padx=20)
    
    save_btn = ctk.CTkButton(btn_area, text="ğŸ’¾ ç¡®è®¤å¹¶ä¿å­˜", command=on_save_confirm, fg_color="#27AE60", width=150)
    save_btn.pack(side="right", padx=20)
    

def show_foreshadowing_records_ui(self):
    """
    [æ–°å¢] æ˜¾ç¤ºä¼ç¬”è®°å½•åº“çš„å¼¹çª—
    """
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœ¨ä¸»Tabä¸­è®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return

    record_file = os.path.join(filepath, "foreshadowing_records.txt")
    if not os.path.exists(record_file):
        messagebox.showinfo("æç¤º", "å½“å‰è¿˜æœªç”Ÿæˆä»»ä½•ä¼ç¬”è®°å½•ã€‚\nè¯·å…ˆè¿›è¡Œç« èŠ‚å®šç¨¿(Finalize)ä»¥è‡ªåŠ¨ç”Ÿæˆã€‚")
        return

    content = read_file(record_file).strip()
    if not content:
        content = "ä¼ç¬”è®°å½•ä¸ºç©ºã€‚"

    top = ctk.CTkToplevel(self.master)
    top.title("å…¨ä¹¦ä¼ç¬”çº¿ç´¢åº“ (Foreshadowing Records)")
    top.geometry("700x600")

    # === ã€ä¿®æ”¹ã€‘ è®¾ç½®ä¸ºä»å±çª—å£ (Transient) ===
    # è¿™æ ·å®ƒæ°¸è¿œä¼šåœ¨ self.master (ä¸»çª—å£) ä¹‹ä¸Šï¼Œä½†ä¸ä¼šæŒ¡ä½å…¶ä»–è½¯ä»¶
    top.transient(self.master)  
    top.lift() # é¦–æ¬¡æ‰“å¼€æ—¶æå‡ä¸€ä¸‹å±‚çº§
    
    # é¡¶éƒ¨è¯´æ˜
    ctk.CTkLabel(top, text="è¿™é‡Œè®°å½•äº†æ¯ä¸€ç« å®šç¨¿æ—¶AIæå–çš„ä¼ç¬”çº¿ç´¢", text_color="gray").pack(pady=5)

    # æ–‡æœ¬åŒºåŸŸ
    text_area = ctk.CTkTextbox(top, wrap="word", font=("Microsoft YaHei", 12))
    text_area.pack(fill="both", expand=True, padx=10, pady=5)
    text_area.insert("0.0", content)
    
    # å…è®¸ç”¨æˆ·æ‰‹åŠ¨ç¼–è¾‘å’Œä¿å­˜æ•´ç†
    def on_save_edit():
        new_text = text_area.get("0.0", "end").strip()
        save_string_to_txt(new_text, record_file)
        messagebox.showinfo("æˆåŠŸ", "ä¼ç¬”è®°å½•å·²ä¿å­˜æ›´æ–°ã€‚")

    btn_frame = ctk.CTkFrame(top)
    btn_frame.pack(fill="x", padx=10, pady=10)
    
    ctk.CTkButton(btn_frame, text="ä¿å­˜ä¿®æ”¹", command=on_save_edit, fg_color="green").pack(side="right")


def show_novel_qa_ui(self):
    """
    [æ–°å¢] å…¨ä¹¦é—®ç­” UI (ç±»ä¼¼èŠå¤©çª—å£)
    """
    filepath = self.filepath_var.get().strip()
    if not filepath:
        messagebox.showwarning("è­¦å‘Š", "è¯·å…ˆåœ¨ä¸»Tabä¸­è®¾ç½®ä¿å­˜æ–‡ä»¶è·¯å¾„")
        return
        
    # åˆ›å»ºå¼¹çª—
    top = ctk.CTkToplevel(self.master)
    top.title("å…¨ä¹¦çŸ¥è¯†åº“é—®ç­” (Novel Q&A)")
    top.geometry("600x700")

    # === ã€ä¿®æ”¹ã€‘ è®¾ç½®ä¸ºä»å±çª—å£ ===
    top.transient(self.master)
    top.lift()
    
    # 1. èŠå¤©è®°å½•æ˜¾ç¤ºåŒº
    history_frame = ctk.CTkFrame(top)
    history_frame.pack(fill="both", expand=True, padx=10, pady=10)
    
    chat_box = ctk.CTkTextbox(history_frame, font=("Microsoft YaHei", 12), state="disabled")
    chat_box.pack(fill="both", expand=True, padx=5, pady=5)
    
    # 2. è¾“å…¥åŒº
    input_frame = ctk.CTkFrame(top)
    input_frame.pack(fill="x", padx=10, pady=(0, 10))
    
    input_entry = ctk.CTkEntry(input_frame, placeholder_text="è¾“å…¥å…³äºå°è¯´çš„é—®é¢˜ï¼Œä¾‹å¦‚ï¼šå¶è½ç°åœ¨çš„ç­‰çº§æ˜¯å¤šå°‘ï¼Ÿ", font=("Microsoft YaHei", 12))
    input_entry.pack(side="left", fill="x", expand=True, padx=(5, 5), pady=5)
    
    # 3. å‘é€é€»è¾‘
    def send_question(event=None):
        question = input_entry.get().strip()
        if not question: return
        
        # æ˜¾ç¤ºç”¨æˆ·é—®é¢˜
        chat_box.configure(state="normal")
        chat_box.insert("end", f"You: {question}\n\n", "user")
        chat_box.insert("end", "AI: æ­£åœ¨ç¿»é˜…å…¨ä¹¦...\n", "system")
        chat_box.see("end")
        chat_box.configure(state="disabled")
        input_entry.delete(0, "end")
        
        def run_qa():
            try:
                # === è·å–é…ç½® ===
                # ä½¿ç”¨ã€é€»è¾‘/å¾®è°ƒæ¨¡å‹ã€‘æ¥å›ç­”é—®é¢˜ï¼Œå› ä¸ºå®ƒé€šå¸¸æ›´ä¾¿å®œä¸”é€»è¾‘å¤Ÿç”¨
                # å¦‚æœæ²¡é…ç½®ï¼Œå›é€€åˆ° draft æ¨¡å‹
                try:
                    llm_key = self.refine_logic_llm_var.get()
                    llm_conf = self.loaded_config["llm_configs"][llm_key]
                except:
                    llm_key = self.prompt_draft_llm_var.get()
                    llm_conf = self.loaded_config["llm_configs"][llm_key]
                
                # === 2. è·å– Embedding é…ç½® (ç”¨äºæ£€ç´¢) ===
                # ã€å…³é”®ä¿®æ”¹ã€‘ï¼šç›´æ¥è¯»å–ä¸»ç•Œé¢å½“å‰ç»‘å®šçš„å˜é‡ï¼Œè€Œä¸æ˜¯è¯»é…ç½®æ–‡ä»¶é‡Œçš„ç¬¬ä¸€ä¸ª
                # è¿™æ ·å¯ä»¥ç¡®ä¿å’Œä½ â€œå®šç¨¿â€æ—¶ç”¨çš„æ˜¯åŒä¸€ä¸ªé…ç½®ï¼Œä¸” API Key ä¸ä¼šä¸ºç©ºï¼ˆåªè¦ä½ ç•Œé¢ä¸Šå¡«äº†ï¼‰
                emb_api_key = self.embedding_api_key_var.get().strip()
                emb_base_url = self.embedding_url_var.get().strip()
                emb_model_name = self.embedding_model_name_var.get().strip()
                emb_interface_format = self.embedding_interface_format_var.get().strip()

                # ç®€å•æ ¡éªŒ
                if not emb_api_key and "ollama" not in emb_interface_format.lower():
                    update_chat("é”™è¯¯ï¼šEmbedding API Key ä¸ºç©ºï¼Œè¯·åœ¨é…ç½®é¡µæ£€æŸ¥ã€‚", is_error=True)
                    return

                # === 3. è°ƒç”¨åç«¯ ===
                answer = answer_novel_question(
                    filepath=filepath,
                    question=question,
                    # LLM å‚æ•°
                    llm_api_key=llm_conf["api_key"],
                    llm_base_url=llm_conf["base_url"],
                    llm_model_name=llm_conf["model_name"],
                    interface_format=llm_conf["interface_format"],
                    # Embedding å‚æ•° (ä½¿ç”¨ç›´æ¥è·å–çš„å€¼)
                    emb_api_key=emb_api_key,
                    emb_base_url=emb_base_url,
                    emb_model_name=emb_model_name,
                    emb_interface_format=emb_interface_format
                )
                
                update_chat(answer)
                
            except Exception as e:
                # æ‰“å°å®Œæ•´å †æ ˆä»¥ä¾¿è°ƒè¯•
                traceback.print_exc() 
                update_chat(f"å‘ç”Ÿé”™è¯¯: {str(e)}", is_error=True)

        threading.Thread(target=run_qa, daemon=True).start()

    def update_chat(text, is_error=False):
        """çº¿ç¨‹å®‰å…¨æ›´æ–° UI"""
        def _update():
            chat_box.configure(state="normal")
            # åˆ é™¤â€œæ­£åœ¨ç¿»é˜…...â€
            # ç®€å•èµ·è§ï¼Œç›´æ¥è¿½åŠ æ–°å†…å®¹ã€‚ä¸ºäº†ä½“éªŒæ›´å¥½ï¼Œå¯ä»¥æŠŠä¸Šä¸€è¡Œåˆ æ‰ï¼Œä½†è¿½åŠ ä¹Ÿæ²¡é—®é¢˜ã€‚
            prefix = "âŒ Error: " if is_error else "AI: "
            chat_box.insert("end", f"\n{prefix}{text}\n" + "-"*30 + "\n\n")
            chat_box.see("end")
            chat_box.configure(state="disabled")
        top.after(0, _update)

    # æŒ‰é’®
    send_btn = ctk.CTkButton(input_frame, text="å‘é€", width=80, command=send_question)
    send_btn.pack(side="right", padx=5, pady=5)
    
    # ç»‘å®šå›è½¦å‘é€
    input_entry.bind("<Return>", send_question)
</file>

</files>
